/*! highcharts.src 2016-01-06 */
!function () {
    function a() {
        var a, b, c = arguments, d = {}, e = function (a, b) {
            var c, d;
            "object" != typeof a && (a = {});
            for (d in b)b.hasOwnProperty(d) && (c = b[d], c && "object" == typeof c && "[object Array]" !== Object.prototype.toString.call(c) && "renderTo" !== d && "number" != typeof c.nodeType ? a[d] = e(a[d] || {}, c) : a[d] = b[d]);
            return a
        };
        for (c[0] === !0 && (d = c[1], c = Array.prototype.slice.call(c, 2)), b = c.length, a = 0; b > a; a++)d = e(d, c[a]);
        return d
    }

    function b(a, b) {
        return parseInt(a, b || 10)
    }

    function c(a) {
        return"string" == typeof a
    }

    function d(a) {
        return a && "object" == typeof a
    }

    function e(a) {
        return"[object Array]" === Object.prototype.toString.call(a)
    }

    function f(a) {
        return"number" == typeof a
    }

    function g(a) {
        return la.log(a) / la.LN10
    }

    function h(a) {
        return la.pow(10, a)
    }

    function i(a, b) {
        for (var c = a.length; c--;)if (a[c] === b) {
            a.splice(c, 1);
            break
        }
    }

    function j(a) {
        return a !== K && null !== a
    }

    function k(a, b, e) {
        var f, g;
        if (c(b))j(e) ? a.setAttribute(b, e) : a && a.getAttribute && (g = a.getAttribute(b)); else if (j(b) && d(b))for (f in b)a.setAttribute(f, b[f]);
        return g
    }

    function l(a) {
        return e(a) ? a : [a]
    }

    function m(a, b) {
        ya && !Ea && b && b.opacity !== K && (b.filter = "alpha(opacity=" + 100 * b.opacity + ")"), db(a.style, b)
    }

    function n(a, b, c, d, e) {
        var f = ja.createElement(a);
        return b && db(f, b), e && m(f, {padding: 0, border: Va, margin: 0}), c && m(f, c), d && d.appendChild(f), f
    }

    function o(a, b) {
        var c = function () {
            return K
        };
        return c.prototype = new a, db(c.prototype, b), c
    }

    function p(a, b) {
        return new Array((b || 2) + 1 - String(a).length).join(0) + a
    }

    function q(a, b) {
        return/%$/.test(a) ? b * parseFloat(a) / 100 : parseFloat(a)
    }

    function r(a) {
        return 6e4 * (W && W(a) || V || 0)
    }

    function s(a, b) {
        var c, d = /f$/, e = /\.([0-9])/, f = O.lang;
        return d.test(a) ? (c = a.match(e), c = c ? c[1] : -1, null !== b && (b = ia.numberFormat(b, c, f.decimalPoint, a.indexOf(",") > -1 ? f.thousandsSep : ""))) : b = P(a, b), b
    }

    function t(a, b) {
        for (var c, d, e, f, g, h, i, j = "{", k = !1, l = []; -1 !== (i = a.indexOf(j));) {
            if (c = a.slice(0, i), k) {
                for (d = c.split(":"), e = d.shift().split("."), g = e.length, h = b, f = 0; g > f; f++)h = h[e[f]];
                d.length && (h = s(d.join(":"), h)), l.push(h)
            } else l.push(c);
            a = a.slice(i + 1), k = !k, j = k ? "}" : "{"
        }
        return l.push(a), l.join("")
    }

    function u(a) {
        return la.pow(10, na(la.log(a) / la.LN10))
    }

    function v(a, b, c, d, e) {
        var f, g, h = a;
        for (c = eb(c, 1), f = a / c, b || (b = [1, 2, 2.5, 5, 10], d === !1 && (1 === c ? b = [1, 2, 5, 10] : .1 >= c && (b = [1 / c]))), g = 0; g < b.length && (h = b[g], !(e && h * c >= a || !e && f <= (b[g] + (b[g + 1] || b[g])) / 2)); g++);
        return h *= c
    }

    function w(a, b) {
        var c, d, e = a.length;
        for (d = 0; e > d; d++)a[d].ss_i = d;
        for (a.sort(function (a, d) {
            return c = b(a, d), 0 === c ? a.ss_i - d.ss_i : c
        }), d = 0; e > d; d++)delete a[d].ss_i
    }

    function x(a) {
        for (var b = a.length, c = a[0]; b--;)a[b] < c && (c = a[b]);
        return c
    }

    function y(a) {
        for (var b = a.length, c = a[0]; b--;)a[b] > c && (c = a[b]);
        return c
    }

    function z(a, b) {
        var c;
        for (c in a)a[c] && a[c] !== b && a[c].destroy && a[c].destroy(), delete a[c]
    }

    function A(a) {
        N || (N = n(Oa)), a && N.appendChild(a), N.innerHTML = ""
    }

    function B(a, b) {
        var c = "Highcharts error #" + a + ": www.highcharts.com/errors/" + a;
        if (b)throw c;
        ka.console && console.log(c)
    }

    function C(a, b) {
        return parseFloat(a.toPrecision(b || 14))
    }

    function D(a, b) {
        b.renderer.globalAnimation = eb(a, b.animation)
    }

    function E() {
        var a = O.global, b = a.useUTC, c = b ? "getUTC" : "get", d = b ? "setUTC" : "set";
        T = a.Date || window.Date, V = b && a.timezoneOffset, W = b && a.getTimezoneOffset, U = function (a, c, d, e, f, g) {
            var h;
            return b ? (h = T.UTC.apply(0, arguments), h += r(h)) : h = new T(a, c, eb(d, 1), eb(e, 0), eb(f, 0), eb(g, 0)).getTime(), h
        }, X = c + "Minutes", Y = c + "Hours", Z = c + "Day", $ = c + "Date", _ = c + "Month", aa = c + "FullYear", ba = d + "Milliseconds", ca = d + "Seconds", da = d + "Minutes", ea = d + "Hours", fa = d + "Date", ga = d + "Month", ha = d + "FullYear"
    }

    function F(b) {
        return O = a(!0, O, b), E(), O
    }

    function G() {
        return O
    }

    function H() {
    }

    function I(a, b, c, d) {
        this.axis = a, this.pos = b, this.type = c || "", this.isNew = !0, c || d || this.addLabel()
    }

    function J(a, b, c, d, e) {
        var f = a.chart.inverted;
        this.axis = a, this.isNegative = c, this.options = b, this.x = d, this.total = null, this.points = {}, this.stack = e, this.alignOptions = {align: b.align || (f ? c ? "left" : "right" : "center"), verticalAlign: b.verticalAlign || (f ? "middle" : c ? "bottom" : "top"), y: eb(b.y, f ? 4 : c ? 14 : -6), x: eb(b.x, f ? c ? -6 : 6 : 0)}, this.textAlign = b.textAlign || (f ? c ? "right" : "left" : "center")
    }

    var K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, $, _, aa, ba, ca, da, ea, fa, ga, ha, ia, ja = document, ka = window, la = Math, ma = la.round, na = la.floor, oa = la.ceil, pa = la.max, qa = la.min, ra = la.abs, sa = la.cos, ta = la.sin, ua = la.PI, va = 2 * ua / 360, wa = navigator.userAgent, xa = ka.opera, ya = /(msie|trident|edge)/i.test(wa) && !xa, za = 8 === ja.documentMode, Aa = !ya && /AppleWebKit/.test(wa), Ba = /Firefox/.test(wa), Ca = /(Mobile|Android|Windows Phone)/.test(wa), Da = "http://www.w3.org/2000/svg", Ea = !!ja.createElementNS && !!ja.createElementNS(Da, "svg").createSVGRect, Fa = Ba && parseInt(wa.split("Firefox/")[1], 10) < 4, Ga = !Ea && !ya && !!ja.createElement("canvas").getContext, Ha = {}, Ia = 0, Ja = function () {
        return K
    }, Ka = [], La = 0, Ma = "Highcharts", Na = "4.1.9", Oa = "div", Pa = "absolute", Qa = "relative", Ra = "hidden", Sa = "highcharts-", Ta = "visible", Ua = "px", Va = "none", Wa = "M", Xa = "L", Ya = /^[0-9]+$/, Za = "", $a = "hover", _a = "select", ab = ["plotTop", "marginRight", "marginBottom", "plotLeft"], bb = "stroke-width", cb = {};
    ia = ka.Highcharts = ka.Highcharts ? B(16, !0) : {}, ia.seriesTypes = cb;
    var db = ia.extend = function (a, b) {
        var c;
        a || (a = {});
        for (c in b)a[c] = b[c];
        return a
    }, eb = ia.pick = function () {
        var a, b, c = arguments, d = c.length;
        for (a = 0; d > a; a++)if (b = c[a], b !== K && null !== b)return b
    }, fb = ia.wrap = function (a, b, c) {
        var d = a[b];
        a[b] = function () {
            var a = Array.prototype.slice.call(arguments);
            return a.unshift(d), c.apply(this, a)
        }
    };
    P = function (a, b, c) {
        if (!j(b) || isNaN(b))return O.lang.invalidDate || "";
        a = eb(a, "%Y-%m-%d %H:%M:%S");
        var d, e = new T(b - r(b)), f = e[Y](), g = e[Z](), h = e[$](), i = e[_](), k = e[aa](), l = O.lang, m = l.weekdays, n = db({a: m[g].substr(0, 3), A: m[g], d: p(h), e: h, w: g, b: l.shortMonths[i], B: l.months[i], m: p(i + 1), y: k.toString().substr(2, 2), Y: k, H: p(f), k: f, I: p(f % 12 || 12), l: f % 12 || 12, M: p(e[X]()), p: 12 > f ? "AM" : "PM", P: 12 > f ? "am" : "pm", S: p(e.getSeconds()), L: p(ma(b % 1e3), 3)}, ia.dateFormats);
        for (d in n)for (; -1 !== a.indexOf("%" + d);)a = a.replace("%" + d, "function" == typeof n[d] ? n[d](b) : n[d]);
        return c ? a.substr(0, 1).toUpperCase() + a.substr(1) : a
    }, R = {millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5, month: 24192e5, year: 314496e5}, ia.numberFormat = function (a, c, d, e) {
        var f = O.lang, g = +a || 0, h = -1 === c ? qa((g.toString().split(".")[1] || "").length, 20) : isNaN(c = ra(c)) ? 2 : c, i = void 0 === d ? f.decimalPoint : d, j = void 0 === e ? f.thousandsSep : e, k = 0 > g ? "-" : "", l = String(b(g = ra(g).toFixed(h))), m = l.length > 3 ? l.length % 3 : 0;
        return k + (m ? l.substr(0, m) + j : "") + l.substr(m).replace(/(\d{3})(?=\d)/g, "$1" + j) + (h ? i + ra(g - l).toFixed(h).slice(2) : "")
    }, Q = {init: function (a, b, c) {
        b = b || "";
        var d, e, f, g, h, i = a.shift, j = b.indexOf("C") > -1, k = j ? 7 : 3, l = b.split(" "), m = [].concat(c), n = function (a) {
            for (f = a.length; f--;)a[f] === Wa && a.splice(f + 1, 0, a[f + 1], a[f + 2], a[f + 1], a[f + 2])
        };
        if (j && (n(l), n(m)), a.isArea && (g = l.splice(l.length - 6, 6), h = m.splice(m.length - 6, 6)), i <= m.length / k && l.length === m.length)for (; i--;)m = [].concat(m).splice(0, k).concat(m);
        if (a.shift = 0, l.length)for (d = m.length; l.length < d;)e = [].concat(l).splice(l.length - k, k), j && (e[k - 6] = e[k - 2], e[k - 5] = e[k - 1]), l = l.concat(e);
        return g && (l = l.concat(g), m = m.concat(h)), [l, m]
    }, step: function (a, b, c, d) {
        var e, f = [], g = a.length;
        if (1 === c)f = d; else if (g === b.length && 1 > c)for (; g--;)e = parseFloat(a[g]), f[g] = isNaN(e) ? a[g] : c * parseFloat(b[g] - e) + e; else f = b;
        return f
    }}, function (a) {
        ka.HighchartsAdapter = ka.HighchartsAdapter || a && {init: function (b) {
            var d = a.fx;
            a.extend(a.easing, {easeOutQuad: function (a, b, c, d, e) {
                return-d * (b /= e) * (b - 2) + c
            }}), a.each(["cur", "_default", "width", "height", "opacity"], function (b, c) {
                var e, f = d.step;
                "cur" === c ? f = d.prototype : "_default" === c && a.Tween && (f = a.Tween.propHooks[c], c = "set"), e = f[c], e && (f[c] = function (a) {
                    var d;
                    return a = b ? a : this, "align" !== a.prop ? (d = a.elem, d.attr ? d.attr(a.prop, "cur" === c ? K : a.now) : e.apply(this, arguments)) : void 0
                })
            }), fb(a.cssHooks.opacity, "get", function (a, b, c) {
                return b.attr ? b.opacity || 0 : a.call(this, b, c)
            }), this.addAnimSetter("d", function (a) {
                var c, d = a.elem;
                a.started || (c = b.init(d, d.d, d.toD), a.start = c[0], a.end = c[1], a.started = !0), d.attr("d", b.step(a.start, a.end, a.pos, d.toD))
            }), this.each = Array.prototype.forEach ? function (a, b) {
                return Array.prototype.forEach.call(a, b)
            } : function (a, b) {
                var c, d = a.length;
                for (c = 0; d > c; c++)if (b.call(a[c], a[c], c, a) === !1)return c
            }, a.fn.highcharts = function () {
                var a, b, d, e = "Chart", f = arguments;
                return this[0] && (c(f[0]) && (e = f[0], f = Array.prototype.slice.call(f, 1)), a = f[0], a !== K && (a.chart = a.chart || {}, a.chart.renderTo = this[0], d = new ia[e](a, f[1]), b = this), a === K && (b = Ka[k(this[0], "data-highcharts-chart")])), b
            }
        }, addAnimSetter: function (b, c) {
            a.Tween ? a.Tween.propHooks[b] = {set: c} : a.fx.step[b] = c
        }, getScript: a.getScript, inArray: a.inArray, adapterRun: function (b, c) {
            return a(b)[c]()
        }, grep: a.grep, map: function (a, b) {
            for (var c = [], d = 0, e = a.length; e > d; d++)c[d] = b.call(a[d], a[d], d, a);
            return c
        }, offset: function (b) {
            return a(b).offset()
        }, addEvent: function (b, c, d) {
            a(b).bind(c, d)
        }, removeEvent: function (b, c, d) {
            var e = ja.removeEventListener ? "removeEventListener" : "detachEvent";
            ja[e] && b && !b[e] && (b[e] = function () {
            }), a(b).unbind(c, d)
        }, fireEvent: function (b, c, d, e) {
            var f, g = a.Event(c), h = "detached" + c;
            !ya && d && (delete d.layerX, delete d.layerY, delete d.returnValue), db(g, d), b[c] && (b[h] = b[c], b[c] = null), a.each(["preventDefault", "stopPropagation"], function (a, b) {
                var c = g[b];
                g[b] = function () {
                    try {
                        c.call(g)
                    } catch (a) {
                        "preventDefault" === b && (f = !0)
                    }
                }
            }), a(b).trigger(g), b[h] && (b[c] = b[h], b[h] = null), !e || g.isDefaultPrevented() || f || e(g)
        }, washMouseEvent: function (a) {
            var b = a.originalEvent || a;
            return b.pageX === K && (b.pageX = a.pageX, b.pageY = a.pageY), b
        }, animate: function (b, c, d) {
            var e = a(b);
            b.style || (b.style = {}), c.d && (b.toD = c.d, c.d = 1), e.stop(), c.opacity !== K && b.attr && (c.opacity += "px"), b.hasAnim = 1, e.animate(c, d)
        }, stop: function (b) {
            b.hasAnim && a(b).stop()
        }}
    }(ka.jQuery);
    var gb = ka.HighchartsAdapter, hb = gb || {};
    gb && gb.init.call(gb, Q);
    var ib = hb.adapterRun, jb = hb.getScript, kb = hb.inArray, lb = ia.each = hb.each, mb = hb.grep, nb = hb.offset, ob = hb.map, pb = hb.addEvent, qb = hb.removeEvent, rb = hb.fireEvent, sb = hb.washMouseEvent, tb = hb.animate, ub = hb.stop;
    O = {colors: ["#7cb5ec", "#434348", "#90ed7d", "#f7a35c", "#8085e9", "#f15c80", "#e4d354", "#2b908f", "#f45b5b", "#91e8e1"], symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: {loading: "Loading...", months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], decimalPoint: ".", numericSymbols: ["k", "M", "G", "T", "P", "E"], resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: " "}, global: {useUTC: !0, canvasToolsURL: "http://code.highcharts.com/4.1.9/modules/canvas-tools.js", VMLRadialGradientURL: "http://code.highcharts.com/4.1.9/gfx/vml-radial-gradient.png"}, chart: {borderColor: "#4572A7", borderRadius: 0, defaultSeriesType: "line", ignoreHiddenSeries: !0, spacing: [10, 10, 15, 10], backgroundColor: "#FFFFFF", plotBorderColor: "#C0C0C0", resetZoomButton: {theme: {zIndex: 20}, position: {align: "right", x: -10, y: 10}}}, title: {text: "", align: "center", margin: 15, style: {color: "#333333", fontSize: "18px"}}, subtitle: {text: "", align: "center", style: {color: "#555555"}}, plotOptions: {line: {allowPointSelect: !1, showCheckbox: !1, animation: {duration: 1e3}, events: {}, lineWidth: 2, marker: {lineWidth: 0, radius: 4, lineColor: "#FFFFFF", states: {hover: {enabled: !0, lineWidthPlus: 1, radiusPlus: 2}, select: {fillColor: "#FFFFFF", lineColor: "#000000", lineWidth: 2}}}, point: {events: {}}, dataLabels: {align: "center", formatter: function () {
        return null === this.y ? "" : ia.numberFormat(this.y, -1)
    }, style: {color: "contrast", fontSize: "11px", fontWeight: "bold", textShadow: "0 0 6px contrast, 0 0 3px contrast"}, verticalAlign: "bottom", x: 0, y: 0, padding: 5}, cropThreshold: 300, pointRange: 0, softThreshold: !0, states: {hover: {lineWidthPlus: 1, marker: {}, halo: {size: 10, opacity: .25}}, select: {marker: {}}}, stickyTracking: !0, turboThreshold: 1e3}}, labels: {style: {position: Pa, color: "#3E576F"}}, legend: {enabled: !0, align: "center", layout: "horizontal", labelFormatter: function () {
        return this.name
    }, borderColor: "#909090", borderRadius: 0, navigation: {activeColor: "#274b6d", inactiveColor: "#CCC"}, shadow: !1, itemStyle: {color: "#333333", fontSize: "12px", fontWeight: "bold"}, itemHoverStyle: {color: "#000"}, itemHiddenStyle: {color: "#CCC"}, itemCheckboxStyle: {position: Pa, width: "13px", height: "13px"}, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: {style: {fontWeight: "bold"}}}, loading: {labelStyle: {fontWeight: "bold", position: Qa, top: "45%"}, style: {position: Pa, backgroundColor: "white", opacity: .5, textAlign: "center"}}, tooltip: {enabled: !0, animation: Ea, backgroundColor: "rgba(249, 249, 249, .85)", borderWidth: 1, borderRadius: 3, dateTimeLabelFormats: {millisecond: "%A, %b %e, %H:%M:%S.%L", second: "%A, %b %e, %H:%M:%S", minute: "%A, %b %e, %H:%M", hour: "%A, %b %e, %H:%M", day: "%A, %b %e, %Y", week: "Week from %A, %b %e, %Y", month: "%B %Y", year: "%Y"}, footerFormat: "", headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>', pointFormat: '<span style="color:{point.color}">●</span> {series.name}: <b>{point.y}</b><br/>', shadow: !0, snap: Ca ? 25 : 10, style: {color: "#333333", cursor: "default", fontSize: "12px", padding: "8px", pointerEvents: "none", whiteSpace: "nowrap"}}, credits: {enabled: !0, text: "Highcharts.com", href: "http://www.highcharts.com", position: {align: "right", x: -10, verticalAlign: "bottom", y: -5}, style: {cursor: "pointer", color: "#909090", fontSize: "9px"}}};
    var vb = O.plotOptions, wb = vb.line;
    E();
    var xb = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, yb = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/, zb = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, Ab = function (c) {
        function d(a) {
            a && a.stops ? j = ob(a.stops, function (a) {
                return Ab(a[1])
            }) : (i = xb.exec(a), i ? k = [b(i[1]), b(i[2]), b(i[3]), parseFloat(i[4], 10)] : (i = yb.exec(a), i ? k = [b(i[1], 16), b(i[2], 16), b(i[3], 16), 1] : (i = zb.exec(a), i && (k = [b(i[1]), b(i[2]), b(i[3]), 1]))))
        }

        function e(b) {
            var d;
            return j ? (d = a(c), d.stops = [].concat(d.stops), lb(j, function (a, c) {
                d.stops[c] = [d.stops[c][0], a.get(b)]
            })) : d = k && !isNaN(k[0]) ? "rgb" === b ? "rgb(" + k[0] + "," + k[1] + "," + k[2] + ")" : "a" === b ? k[3] : "rgba(" + k.join(",") + ")" : c, d
        }

        function g(a) {
            if (j)lb(j, function (b) {
                b.brighten(a)
            }); else if (f(a) && 0 !== a) {
                var c;
                for (c = 0; 3 > c; c++)k[c] += b(255 * a), k[c] < 0 && (k[c] = 0), k[c] > 255 && (k[c] = 255)
            }
            return this
        }

        function h(a) {
            return k[3] = a, this
        }

        var i, j, k = [];
        return d(c), {get: e, brighten: g, rgba: k, setOpacity: h, raw: c}
    };
    H.prototype = {opacity: 1, textProps: ["fontSize", "fontWeight", "fontFamily", "fontStyle", "color", "lineHeight", "width", "textDecoration", "textOverflow", "textShadow"], init: function (a, b) {
        var c = this;
        c.element = "span" === b ? n(b) : ja.createElementNS(Da, b), c.renderer = a
    }, animate: function (b, c, d) {
        var e = eb(c, this.renderer.globalAnimation, !0);
        return ub(this), e ? (e = a(e, {}), d && (e.complete = d), tb(this, b, e)) : this.attr(b, null, d), this
    }, colorGradient: function (b, c, d) {
        var f, g, h, i, k, l, m, n, o, p, q, r, s = this.renderer, t = [];
        if (b.linearGradient ? g = "linearGradient" : b.radialGradient && (g = "radialGradient"), g) {
            h = b[g], k = s.gradients, m = b.stops, p = d.radialReference, e(h) && (b[g] = h = {x1: h[0], y1: h[1], x2: h[2], y2: h[3], gradientUnits: "userSpaceOnUse"}), "radialGradient" === g && p && !j(h.gradientUnits) && (i = h, h = a(h, s.getRadialAttr(p, i), {gradientUnits: "userSpaceOnUse"}));
            for (q in h)"id" !== q && t.push(q, h[q]);
            for (q in m)t.push(m[q]);
            t = t.join(","), k[t] ? r = k[t].attr("id") : (h.id = r = Sa + Ia++, k[t] = l = s.createElement(g).attr(h).add(s.defs), l.radAttr = i, l.stops = [], lb(m, function (a) {
                var b;
                0 === a[1].indexOf("rgba") ? (f = Ab(a[1]), n = f.get("rgb"), o = f.get("a")) : (n = a[1], o = 1), b = s.createElement("stop").attr({offset: a[0], "stop-color": n, "stop-opacity": o}).add(l), l.stops.push(b)
            })), d.setAttribute(c, "url(" + s.url + "#" + r + ")"), d.gradient = t
        }
    }, applyTextShadow: function (a) {
        var c, d = this.element, e = -1 !== a.indexOf("contrast"), f = {}, g = this.renderer.forExport, h = g || d.style.textShadow !== K && !ya;
        e && (f.textShadow = a = a.replace(/contrast/g, this.renderer.getContrast(d.style.fill))), (Aa || g) && (f.textRendering = "geometricPrecision"), h ? this.css(f) : (this.fakeTS = !0, this.ySetter = this.xSetter, c = [].slice.call(d.getElementsByTagName("tspan")), lb(a.split(/\s?,\s?/g), function (a) {
            var e, f, g = d.firstChild;
            a = a.split(" "), e = a[a.length - 1], f = a[a.length - 2], f && lb(c, function (a, c) {
                var h;
                0 === c && (a.setAttribute("x", d.getAttribute("x")), c = d.getAttribute("y"), a.setAttribute("y", c || 0), null === c && d.setAttribute("y", 0)), h = a.cloneNode(1), k(h, {"class": Sa + "text-shadow", fill: e, stroke: e, "stroke-opacity": 1 / pa(b(f), 3), "stroke-width": f, "stroke-linejoin": "round"}), d.insertBefore(h, g)
            })
        }))
    }, attr: function (a, b, c) {
        var d, e, f, g, h = this.element, i = this;
        if ("string" == typeof a && b !== K && (d = a, a = {}, a[d] = b), "string" == typeof a)i = (this[a + "Getter"] || this._defaultGetter).call(this, a, h); else {
            for (d in a)e = a[d], g = !1, this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(d) && (f || (this.symbolAttr(a), f = !0), g = !0), !this.rotation || "x" !== d && "y" !== d || (this.doTransform = !0), g || (this[d + "Setter"] || this._defaultSetter).call(this, e, d, h), this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(d) && this.updateShadows(d, e);
            this.doTransform && (this.updateTransform(), this.doTransform = !1)
        }
        return c && c(), i
    }, updateShadows: function (a, b) {
        for (var c = this.shadows, d = c.length; d--;)c[d].setAttribute(a, "height" === a ? pa(b - (c[d].cutHeight || 0), 0) : "d" === a ? this.d : b)
    }, addClass: function (a) {
        var b = this.element, c = k(b, "class") || "";
        return-1 === c.indexOf(a) && k(b, "class", c + " " + a), this
    }, symbolAttr: function (a) {
        var b = this;
        lb(["x", "y", "r", "start", "end", "width", "height", "innerR", "anchorX", "anchorY"], function (c) {
            b[c] = eb(a[c], b[c])
        }), b.attr({d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)})
    }, clip: function (a) {
        return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : Va)
    }, crisp: function (a) {
        var b, c, d = this, e = {}, f = a.strokeWidth || d.strokeWidth || 0;
        c = ma(f) % 2 / 2, a.x = na(a.x || d.x || 0) + c, a.y = na(a.y || d.y || 0) + c, a.width = na((a.width || d.width || 0) - 2 * c), a.height = na((a.height || d.height || 0) - 2 * c), a.strokeWidth = f;
        for (b in a)d[b] !== a[b] && (d[b] = e[b] = a[b]);
        return e
    }, css: function (a) {
        var c, d, e, f = this, g = f.styles, h = {}, i = f.element, j = "", l = !g;
        if (a && a.color && (a.fill = a.color), g)for (d in a)a[d] !== g[d] && (h[d] = a[d], l = !0);
        if (l) {
            if (c = f.textWidth = a && a.width && "text" === i.nodeName.toLowerCase() && b(a.width) || f.textWidth, g && (a = db(g, h)), f.styles = a, c && (Ga || !Ea && f.renderer.forExport) && delete a.width, ya && !Ea)m(f.element, a); else {
                e = function (a, b) {
                    return"-" + b.toLowerCase()
                };
                for (d in a)j += d.replace(/([A-Z])/g, e) + ":" + a[d] + ";";
                k(i, "style", j)
            }
            c && f.added && f.renderer.buildText(f)
        }
        return f
    }, on: function (a, b) {
        var c = this, d = c.element;
        return M && "click" === a ? (d.ontouchstart = function (a) {
            c.touchEventFired = T.now(), a.preventDefault(), b.call(d, a)
        }, d.onclick = function (a) {
            (-1 === wa.indexOf("Android") || T.now() - (c.touchEventFired || 0) > 1100) && b.call(d, a)
        }) : d["on" + a] = b, this
    }, setRadialReference: function (a) {
        var b = this.renderer.gradients[this.element.gradient];
        return this.element.radialReference = a, b && b.radAttr && b.animate(this.renderer.getRadialAttr(a, b.radAttr)), this
    }, translate: function (a, b) {
        return this.attr({translateX: a, translateY: b})
    }, invert: function () {
        var a = this;
        return a.inverted = !0, a.updateTransform(), a
    }, updateTransform: function () {
        var a, b = this, c = b.translateX || 0, d = b.translateY || 0, e = b.scaleX, f = b.scaleY, g = b.inverted, h = b.rotation, i = b.element;
        g && (c += b.attr("width"), d += b.attr("height")), a = ["translate(" + c + "," + d + ")"], g ? a.push("rotate(90) scale(-1,1)") : h && a.push("rotate(" + h + " " + (i.getAttribute("x") || 0) + " " + (i.getAttribute("y") || 0) + ")"), (j(e) || j(f)) && a.push("scale(" + eb(e, 1) + " " + eb(f, 1) + ")"), a.length && i.setAttribute("transform", a.join(" "))
    }, toFront: function () {
        var a = this.element;
        return a.parentNode.appendChild(a), this
    }, align: function (a, b, d) {
        var e, f, g, h, j, k = {}, l = this.renderer, m = l.alignedObjects;
        return a ? (this.alignOptions = a, this.alignByTranslate = b, (!d || c(d)) && (this.alignTo = j = d || "renderer", i(m, this), m.push(this), d = null)) : (a = this.alignOptions, b = this.alignByTranslate, j = this.alignTo), d = eb(d, l[j], l), e = a.align, f = a.verticalAlign, g = (d.x || 0) + (a.x || 0), h = (d.y || 0) + (a.y || 0), ("right" === e || "center" === e) && (g += (d.width - (a.width || 0)) / {right: 1, center: 2}[e]), k[b ? "translateX" : "x"] = ma(g), ("bottom" === f || "middle" === f) && (h += (d.height - (a.height || 0)) / ({bottom: 1, middle: 2}[f] || 1)), k[b ? "translateY" : "y"] = ma(h), this[this.placed ? "animate" : "attr"](k), this.placed = !0, this.alignAttr = k, this
    }, getBBox: function (a) {
        var b, c, d, e, f, g, h = this, i = h.renderer, j = h.rotation, k = h.element, l = h.styles, m = j * va, n = h.textStr, o = k.style;
        if (n !== K && (g = ["", j || 0, l && l.fontSize, k.style.width].join(","), g = "" === n || Ya.test(n) ? "num:" + n.toString().length + g : n + g), g && !a && (b = i.cache[g]), !b) {
            if (k.namespaceURI === Da || i.forExport) {
                try {
                    f = this.fakeTS && function (a) {
                        lb(k.querySelectorAll("." + Sa + "text-shadow"), function (b) {
                            b.style.display = a
                        })
                    }, Ba && o.textShadow ? (e = o.textShadow, o.textShadow = "") : f && f(Va), b = k.getBBox ? db({}, k.getBBox()) : {width: k.offsetWidth, height: k.offsetHeight}, e ? o.textShadow = e : f && f("")
                } catch (p) {
                }
                (!b || b.width < 0) && (b = {width: 0, height: 0})
            } else b = h.htmlGetBBox();
            i.isSVG && (c = b.width, d = b.height, ya && l && "11px" === l.fontSize && "16.9" === d.toPrecision(3) && (b.height = d = 14), j && (b.width = ra(d * ta(m)) + ra(c * sa(m)), b.height = ra(d * sa(m)) + ra(c * ta(m)))), g && (i.cache[g] = b)
        }
        return b
    }, show: function (a) {
        return this.attr({visibility: a ? "inherit" : Ta})
    }, hide: function () {
        return this.attr({visibility: Ra})
    }, fadeOut: function (a) {
        var b = this;
        b.animate({opacity: 0}, {duration: a || 150, complete: function () {
            b.attr({y: -9999})
        }})
    }, add: function (a) {
        var b, c = this.renderer, d = this.element;
        return a && (this.parentGroup = a), this.parentInverted = a && a.inverted, void 0 !== this.textStr && c.buildText(this), this.added = !0, (!a || a.handleZ || this.zIndex) && (b = this.zIndexSetter()), b || (a ? a.element : c.box).appendChild(d), this.onAdd && this.onAdd(), this
    }, safeRemoveChild: function (a) {
        var b = a.parentNode;
        b && b.removeChild(a)
    }, destroy: function () {
        var a, b, c, d = this, e = d.element || {}, f = d.shadows, g = d.renderer.isSVG && "SPAN" === e.nodeName && d.parentGroup;
        if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, ub(d), d.clipPath && (d.clipPath = d.clipPath.destroy()), d.stops) {
            for (c = 0; c < d.stops.length; c++)d.stops[c] = d.stops[c].destroy();
            d.stops = null
        }
        for (d.safeRemoveChild(e), f && lb(f, function (a) {
            d.safeRemoveChild(a)
        }); g && g.div && 0 === g.div.childNodes.length;)a = g.parentGroup, d.safeRemoveChild(g.div), delete g.div, g = a;
        d.alignTo && i(d.renderer.alignedObjects, d);
        for (b in d)delete d[b];
        return null
    }, shadow: function (a, b, c) {
        var d, e, f, g, h, i, j = [], l = this.element;
        if (a) {
            for (g = eb(a.width, 3), h = (a.opacity || .15) / g, i = this.parentInverted ? "(-1,-1)" : "(" + eb(a.offsetX, 1) + ", " + eb(a.offsetY, 1) + ")", d = 1; g >= d; d++)e = l.cloneNode(0), f = 2 * g + 1 - 2 * d, k(e, {isShadow: "true", stroke: a.color || "black", "stroke-opacity": h * d, "stroke-width": f, transform: "translate" + i, fill: Va}), c && (k(e, "height", pa(k(e, "height") - f, 0)), e.cutHeight = f), b ? b.element.appendChild(e) : l.parentNode.insertBefore(e, l), j.push(e);
            this.shadows = j
        }
        return this
    }, xGetter: function (a) {
        return"circle" === this.element.nodeName && (a = {x: "cx", y: "cy"}[a] || a), this._defaultGetter(a)
    }, _defaultGetter: function (a) {
        var b = eb(this[a], this.element ? this.element.getAttribute(a) : null, 0);
        return/^[\-0-9\.]+$/.test(b) && (b = parseFloat(b)), b
    }, dSetter: function (a, b, c) {
        a && a.join && (a = a.join(" ")), /(NaN| {2}|^$)/.test(a) && (a = "M 0 0"), c.setAttribute(b, a), this[b] = a
    }, dashstyleSetter: function (a) {
        var c;
        if (a = a && a.toLowerCase()) {
            for (a = a.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(","), c = a.length; c--;)a[c] = b(a[c]) * this["stroke-width"];
            a = a.join(",").replace("NaN", "none"), this.element.setAttribute("stroke-dasharray", a)
        }
    }, alignSetter: function (a) {
        this.element.setAttribute("text-anchor", {left: "start", center: "middle", right: "end"}[a])
    }, opacitySetter: function (a, b, c) {
        this[b] = a, c.setAttribute(b, a)
    }, titleSetter: function (a) {
        var b = this.element.getElementsByTagName("title")[0];
        b || (b = ja.createElementNS(Da, "title"), this.element.appendChild(b)), b.appendChild(ja.createTextNode(String(eb(a), "").replace(/<[^>]*>/g, "")))
    }, textSetter: function (a) {
        a !== this.textStr && (delete this.bBox, this.textStr = a, this.added && this.renderer.buildText(this))
    }, fillSetter: function (a, b, c) {
        "string" == typeof a ? c.setAttribute(b, a) : a && this.colorGradient(a, b, c)
    }, visibilitySetter: function (a, b, c) {
        "inherit" === a ? c.removeAttribute(b) : c.setAttribute(b, a)
    }, zIndexSetter: function (a, c) {
        var d, e, f, g, h, i = this.renderer, l = this.parentGroup, m = l || i, n = m.element || i.box, o = this.element, p = this.added;
        if (j(a) && (o.setAttribute(c, a), a = +a, this[c] === a && (p = !1), this[c] = a), p) {
            for (a = this.zIndex, a && l && (l.handleZ = !0), d = n.childNodes, h = 0; h < d.length && !g; h++)e = d[h], f = k(e, "zIndex"), e !== o && (b(f) > a || !j(a) && j(f)) && (n.insertBefore(o, e), g = !0);
            g || n.appendChild(o)
        }
        return g
    }, _defaultSetter: function (a, b, c) {
        c.setAttribute(b, a)
    }}, H.prototype.yGetter = H.prototype.xGetter, H.prototype.translateXSetter = H.prototype.translateYSetter = H.prototype.rotationSetter = H.prototype.verticalAlignSetter = H.prototype.scaleXSetter = H.prototype.scaleYSetter = function (a, b) {
        this[b] = a, this.doTransform = !0
    }, H.prototype["stroke-widthSetter"] = H.prototype.strokeSetter = function (a, b, c) {
        this[b] = a, this.stroke && this["stroke-width"] ? (this.strokeWidth = this["stroke-width"], H.prototype.fillSetter.call(this, this.stroke, "stroke", c), c.setAttribute("stroke-width", this["stroke-width"]), this.hasStroke = !0) : "stroke-width" === b && 0 === a && this.hasStroke && (c.removeAttribute("stroke"), this.hasStroke = !1)
    };
    var Bb = function () {
        this.init.apply(this, arguments)
    };
    Bb.prototype = {Element: H, init: function (a, b, c, d, e, f) {
        var g, h, i, j = this, l = location;
        g = j.createElement("svg").attr({version: "1.1"}).css(this.getStyle(d)), h = g.element, a.appendChild(h), -1 === a.innerHTML.indexOf("xmlns") && k(h, "xmlns", Da), j.isSVG = !0, j.box = h, j.boxWrapper = g, j.alignedObjects = [], j.url = (Ba || Aa) && ja.getElementsByTagName("base").length ? l.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "", i = this.createElement("desc").add(), i.element.appendChild(ja.createTextNode("Created with " + Ma + " " + Na)), j.defs = this.createElement("defs").add(), j.allowHTML = f, j.forExport = e, j.gradients = {}, j.cache = {}, j.setSize(b, c, !1);
        var n, o;
        Ba && a.getBoundingClientRect && (j.subPixelFix = n = function () {
            m(a, {left: 0, top: 0}), o = a.getBoundingClientRect(), m(a, {left: oa(o.left) - o.left + Ua, top: oa(o.top) - o.top + Ua})
        }, n(), pb(ka, "resize", n))
    }, getStyle: function (a) {
        return this.style = db({fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', fontSize: "12px"}, a)
    }, isHidden: function () {
        return!this.boxWrapper.getBBox().width
    }, destroy: function () {
        var a = this, b = a.defs;
        return a.box = null, a.boxWrapper = a.boxWrapper.destroy(), z(a.gradients || {}), a.gradients = null, b && (a.defs = b.destroy()), a.subPixelFix && qb(ka, "resize", a.subPixelFix), a.alignedObjects = null, null
    }, createElement: function (a) {
        var b = new this.Element;
        return b.init(this, a), b
    }, draw: function () {
    }, getRadialAttr: function (a, b) {
        return{cx: a[0] - a[2] / 2 + b.cx * a[2], cy: a[1] - a[2] / 2 + b.cy * a[2], r: b.r * a[2]}
    }, buildText: function (a) {
        for (var c, d, e, f = a.element, g = this, h = g.forExport, i = eb(a.textStr, "").toString(), j = -1 !== i.indexOf("<"), l = f.childNodes, n = k(f, "x"), o = a.styles, p = a.textWidth, q = o && o.lineHeight, r = o && o.textShadow, s = o && "ellipsis" === o.textOverflow, t = l.length, u = p && !a.added && this.box, v = function (a) {
            return q ? b(q) : g.fontMetrics(/(px|em)$/.test(a && a.style.fontSize) ? a.style.fontSize : o && o.fontSize || g.style.fontSize || 12, a).h
        }, w = function (a) {
            return a.replace(/&lt;/g, "<").replace(/&gt;/g, ">")
        }; t--;)f.removeChild(l[t]);
        return j || r || s || -1 !== i.indexOf(" ") ? (d = /<.*style="([^"]+)".*>/, e = /<.*href="(http[^"]+)".*>/, u && u.appendChild(f), c = j ? i.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g) : [i], "" === c[c.length - 1] && c.pop(), lb(c, function (b, c) {
            var i, j = 0;
            b = b.replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||"), i = b.split("|||"), lb(i, function (b) {
                if ("" !== b || 1 === i.length) {
                    var l, q = {}, r = ja.createElementNS(Da, "tspan");
                    if (d.test(b) && (l = b.match(d)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), k(r, "style", l)), e.test(b) && !h && (k(r, "onclick", 'location.href="' + b.match(e)[1] + '"'), m(r, {cursor: "pointer"})), b = w(b.replace(/<(.|\n)*?>/g, "") || " "), " " !== b) {
                        if (r.appendChild(ja.createTextNode(b)), j ? q.dx = 0 : c && null !== n && (q.x = n), k(r, q), f.appendChild(r), !j && c && (!Ea && h && m(r, {display: "block"}), k(r, "dy", v(r))), p) {
                            for (var t, u, x, y, z = b.replace(/([^\^])-/g, "$1- ").split(" "), A = i.length > 1 || c || z.length > 1 && "nowrap" !== o.whiteSpace, B = [], C = v(r), D = 1, E = a.rotation, F = b, G = F.length; (A || s) && (z.length || B.length);)a.rotation = 0, y = a.getBBox(!0), x = y.width, !Ea && g.forExport && (x = g.measureSpanWidth(r.firstChild.data, a.styles)), t = x > p, void 0 === u && (u = t), s && u ? (G /= 2, "" === F || !t && .5 > G ? z = [] : (t && (u = !0), F = b.substring(0, F.length + (t ? -1 : 1) * oa(G)), z = [F + (p > 3 ? "…" : "")], r.removeChild(r.firstChild))) : t && 1 !== z.length ? (r.removeChild(r.firstChild), B.unshift(z.pop())) : (z = B, B = [], z.length && (D++, r = ja.createElementNS(Da, "tspan"), k(r, {dy: C, x: n}), l && k(r, "style", l), f.appendChild(r)), x > p && (p = x)), z.length && r.appendChild(ja.createTextNode(z.join(" ").replace(/- /g, "-")));
                            u && a.attr("title", a.textStr), a.rotation = E
                        }
                        j++
                    }
                }
            })
        }), u && u.removeChild(f), r && a.applyTextShadow && a.applyTextShadow(r), void 0) : void f.appendChild(ja.createTextNode(w(i)))
    }, getContrast: function (a) {
        return a = Ab(a).rgba, a[0] + a[1] + a[2] > 384 ? "#000000" : "#FFFFFF"
    }, button: function (b, c, d, e, f, g, h, i, j) {
        var k, l, m, n, o, p, q = this.label(b, c, d, j, null, null, null, null, "button"), r = 0, s = {x1: 0, y1: 0, x2: 0, y2: 1};
        return f = a({"stroke-width": 1, stroke: "#CCCCCC", fill: {linearGradient: s, stops: [
            [0, "#FEFEFE"],
            [1, "#F6F6F6"]
        ]}, r: 2, padding: 5, style: {color: "black"}}, f), m = f.style, delete f.style, g = a(f, {stroke: "#68A", fill: {linearGradient: s, stops: [
            [0, "#FFF"],
            [1, "#ACF"]
        ]}}, g), n = g.style, delete g.style, h = a(f, {stroke: "#68A", fill: {linearGradient: s, stops: [
            [0, "#9BD"],
            [1, "#CDF"]
        ]}}, h), o = h.style, delete h.style, i = a(f, {style: {color: "#CCC"}}, i), p = i.style, delete i.style, pb(q.element, ya ? "mouseover" : "mouseenter", function () {
            3 !== r && q.attr(g).css(n)
        }), pb(q.element, ya ? "mouseout" : "mouseleave", function () {
            3 !== r && (k = [f, g, h][r], l = [m, n, o][r], q.attr(k).css(l))
        }), q.setState = function (a) {
            q.state = r = a, a ? 2 === a ? q.attr(h).css(o) : 3 === a && q.attr(i).css(p) : q.attr(f).css(m)
        }, q.on("click", function (a) {
            3 !== r && e.call(q, a)
        }).attr(f).css(db({cursor: "default"}, m))
    }, crispLine: function (a, b) {
        return a[1] === a[4] && (a[1] = a[4] = ma(a[1]) - b % 2 / 2), a[2] === a[5] && (a[2] = a[5] = ma(a[2]) + b % 2 / 2), a
    }, path: function (a) {
        var b = {fill: Va};
        return e(a) ? b.d = a : d(a) && db(b, a), this.createElement("path").attr(b)
    }, circle: function (a, b, c) {
        var e = d(a) ? a : {x: a, y: b, r: c}, f = this.createElement("circle");
        return f.xSetter = function (a) {
            this.element.setAttribute("cx", a)
        }, f.ySetter = function (a) {
            this.element.setAttribute("cy", a)
        }, f.attr(e)
    }, arc: function (a, b, c, e, f, g) {
        var h;
        return d(a) && (b = a.y, c = a.r, e = a.innerR, f = a.start, g = a.end, a = a.x), h = this.symbol("arc", a || 0, b || 0, c || 0, c || 0, {innerR: e || 0, start: f || 0, end: g || 0}), h.r = c, h
    }, rect: function (a, b, c, e, f, g) {
        f = d(a) ? a.r : f;
        var h = this.createElement("rect"), i = d(a) ? a : a === K ? {} : {x: a, y: b, width: pa(c, 0), height: pa(e, 0)};
        return g !== K && (i.strokeWidth = g, i = h.crisp(i)), f && (i.r = f), h.rSetter = function (a) {
            k(this.element, {rx: a, ry: a})
        }, h.attr(i)
    }, setSize: function (a, b, c) {
        var d = this, e = d.alignedObjects, f = e.length;
        for (d.width = a, d.height = b, d.boxWrapper[eb(c, !0) ? "animate" : "attr"]({width: a, height: b}); f--;)e[f].align()
    }, g: function (a) {
        var b = this.createElement("g");
        return j(a) ? b.attr({"class": Sa + a}) : b
    }, image: function (a, b, c, d, e) {
        var f, g = {preserveAspectRatio: Va};
        return arguments.length > 1 && db(g, {x: b, y: c, width: d, height: e}), f = this.createElement("image").attr(g), f.element.setAttributeNS ? f.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", a) : f.element.setAttribute("hc-svg-href", a), f
    }, symbol: function (a, b, c, d, e, f) {
        var g, h, i, j, k, l = this.symbols[a], o = l && l(ma(b), ma(c), d, e, f), p = /^url\((.*?)\)$/;
        return o ? (g = this.path(o), db(g, {symbolName: a, x: b, y: c, width: d, height: e}), f && db(g, f)) : p.test(a) && (k = function (a, b) {
            a.element && (a.attr({width: b[0], height: b[1]}), a.alignByTranslate || a.translate(ma((d - b[0]) / 2), ma((e - b[1]) / 2)))
        }, i = a.match(p)[1], j = Ha[i] || f && f.width && f.height && [f.width, f.height], g = this.image(i).attr({x: b, y: c}), g.isImg = !0, j ? k(g, j) : (g.attr({width: 0, height: 0}), h = n("img", {onload: function () {
            0 === this.width && (m(this, {position: Pa, top: "-999em"}), document.body.appendChild(this)), k(g, Ha[i] = [this.width, this.height]), this.parentNode && this.parentNode.removeChild(this)
        }, src: i}))), g
    }, symbols: {circle: function (a, b, c, d) {
        var e = .166 * c;
        return[Wa, a + c / 2, b, "C", a + c + e, b, a + c + e, b + d, a + c / 2, b + d, "C", a - e, b + d, a - e, b, a + c / 2, b, "Z"]
    }, square: function (a, b, c, d) {
        return[Wa, a, b, Xa, a + c, b, a + c, b + d, a, b + d, "Z"];
    }, triangle: function (a, b, c, d) {
        return[Wa, a + c / 2, b, Xa, a + c, b + d, a, b + d, "Z"]
    }, "triangle-down": function (a, b, c, d) {
        return[Wa, a, b, Xa, a + c, b, a + c / 2, b + d, "Z"]
    }, diamond: function (a, b, c, d) {
        return[Wa, a + c / 2, b, Xa, a + c, b + d / 2, a + c / 2, b + d, a, b + d / 2, "Z"]
    }, arc: function (a, b, c, d, e) {
        var f = e.start, g = e.r || c || d, h = e.end - .001, i = e.innerR, j = e.open, k = sa(f), l = ta(f), m = sa(h), n = ta(h), o = e.end - f < ua ? 0 : 1;
        return[Wa, a + g * k, b + g * l, "A", g, g, 0, o, 1, a + g * m, b + g * n, j ? Wa : Xa, a + i * m, b + i * n, "A", i, i, 0, o, 0, a + i * k, b + i * l, j ? "" : "Z"]
    }, callout: function (a, b, c, d, e) {
        var f, g = 6, h = 6, i = qa(e && e.r || 0, c, d), j = i + h, k = e && e.anchorX, l = e && e.anchorY;
        return f = ["M", a + i, b, "L", a + c - i, b, "C", a + c, b, a + c, b, a + c, b + i, "L", a + c, b + d - i, "C", a + c, b + d, a + c, b + d, a + c - i, b + d, "L", a + i, b + d, "C", a, b + d, a, b + d, a, b + d - i, "L", a, b + i, "C", a, b, a, b, a + i, b], k && k > c && l > b + j && b + d - j > l ? f.splice(13, 3, "L", a + c, l - h, a + c + g, l, a + c, l + h, a + c, b + d - i) : k && 0 > k && l > b + j && b + d - j > l ? f.splice(33, 3, "L", a, l + h, a - g, l, a, l - h, a, b + i) : l && l > d && k > a + j && a + c - j > k ? f.splice(23, 3, "L", k + h, b + d, k, b + d + g, k - h, b + d, a + i, b + d) : l && 0 > l && k > a + j && a + c - j > k && f.splice(3, 3, "L", k - h, b, k, b - g, k + h, b, c - i, b), f
    }}, clipRect: function (a, b, c, d) {
        var e, f = Sa + Ia++, g = this.createElement("clipPath").attr({id: f}).add(this.defs);
        return e = this.rect(a, b, c, d, 0).add(g), e.id = f, e.clipPath = g, e.count = 0, e
    }, text: function (a, b, c, d) {
        var e, f = this, g = Ga || !Ea && f.forExport, h = {};
        return!d || !f.allowHTML && f.forExport ? (h.x = Math.round(b || 0), c && (h.y = Math.round(c)), (a || 0 === a) && (h.text = a), e = f.createElement("text").attr(h), g && e.css({position: Pa}), d || (e.xSetter = function (a, b, c) {
            var d, e, f = c.getElementsByTagName("tspan"), g = c.getAttribute(b);
            for (e = 0; e < f.length; e++)d = f[e], d.getAttribute(b) === g && d.setAttribute(b, a);
            c.setAttribute(b, a)
        }), e) : f.html(a, b, c)
    }, fontMetrics: function (a, c) {
        var d, e, f;
        return a = a || this.style.fontSize, !a && c && ka.getComputedStyle && (c = c.element || c, f = ka.getComputedStyle(c, ""), a = f && f.fontSize), a = /px/.test(a) ? b(a) : /em/.test(a) ? 12 * parseFloat(a) : 12, d = 24 > a ? a + 3 : ma(1.2 * a), e = ma(.8 * d), {h: d, b: e, f: a}
    }, rotCorr: function (a, b, c) {
        var d = a;
        return b && c && (d = pa(d * sa(b * va), 4)), {x: -a / 3 * ta(b * va), y: d}
    }, label: function (b, c, d, e, f, g, h, i, k) {
        function l() {
            var a, b, c = y.element.style;
            p = (void 0 === q || void 0 === r || x.styles.textAlign) && j(y.textStr) && y.getBBox(), x.width = (q || p.width || 0) + 2 * A + B, x.height = (r || p.height || 0) + 2 * A, u = A + w.fontMetrics(c && c.fontSize, y).b, v && (o || (a = ma(-z * A) + C, b = (i ? -u : 0) + C, x.box = o = e ? w.symbol(e, a, b, x.width, x.height, D) : w.rect(a, b, x.width, x.height, 0, D[bb]), o.isImg || o.attr("fill", Va), o.add(x)), o.isImg || o.attr(db({width: ma(x.width), height: ma(x.height)}, D)), D = null)
        }

        function m() {
            var a, b = x.styles, c = b && b.textAlign, d = B + A * (1 - z);
            a = i ? 0 : u, j(q) && p && ("center" === c || "right" === c) && (d += {center: .5, right: 1}[c] * (q - p.width)), (d !== y.x || a !== y.y) && (y.attr("x", d), a !== K && y.attr("y", a)), y.x = d, y.y = a
        }

        function n(a, b) {
            o ? o.attr(a, b) : D[a] = b
        }

        var o, p, q, r, s, t, u, v, w = this, x = w.g(k), y = w.text("", 0, 0, h).attr({zIndex: 1}), z = 0, A = 3, B = 0, C = 0, D = {};
        x.onAdd = function () {
            y.add(x), x.attr({text: b || 0 === b ? b : "", x: c, y: d}), o && j(f) && x.attr({anchorX: f, anchorY: g})
        }, x.widthSetter = function (a) {
            q = a
        }, x.heightSetter = function (a) {
            r = a
        }, x.paddingSetter = function (a) {
            j(a) && a !== A && (A = x.padding = a, m())
        }, x.paddingLeftSetter = function (a) {
            j(a) && a !== B && (B = a, m())
        }, x.alignSetter = function (a) {
            z = {left: 0, center: .5, right: 1}[a]
        }, x.textSetter = function (a) {
            a !== K && y.textSetter(a), l(), m()
        }, x["stroke-widthSetter"] = function (a, b) {
            a && (v = !0), C = a % 2 / 2, n(b, a)
        }, x.strokeSetter = x.fillSetter = x.rSetter = function (a, b) {
            "fill" === b && a && (v = !0), n(b, a)
        }, x.anchorXSetter = function (a, b) {
            f = a, n(b, ma(a) - C - s)
        }, x.anchorYSetter = function (a, b) {
            g = a, n(b, a - t)
        }, x.xSetter = function (a) {
            x.x = a, z && (a -= z * ((q || p.width) + A)), s = ma(a), x.attr("translateX", s)
        }, x.ySetter = function (a) {
            t = x.y = ma(a), x.attr("translateY", t)
        };
        var E = x.css;
        return db(x, {css: function (b) {
            if (b) {
                var c = {};
                b = a(b), lb(x.textProps, function (a) {
                    b[a] !== K && (c[a] = b[a], delete b[a])
                }), y.css(c)
            }
            return E.call(x, b)
        }, getBBox: function () {
            return{width: p.width + 2 * A, height: p.height + 2 * A, x: p.x - A, y: p.y - A}
        }, shadow: function (a) {
            return o && o.shadow(a), x
        }, destroy: function () {
            qb(x.element, "mouseenter"), qb(x.element, "mouseleave"), y && (y = y.destroy()), o && (o = o.destroy()), H.prototype.destroy.call(x), x = w = l = m = n = null
        }})
    }}, L = Bb, db(H.prototype, {htmlCss: function (a) {
        var b = this, c = b.element, d = a && "SPAN" === c.tagName && a.width;
        return d && (delete a.width, b.textWidth = d, b.updateTransform()), a && "ellipsis" === a.textOverflow && (a.whiteSpace = "nowrap", a.overflow = "hidden"), b.styles = db(b.styles, a), m(b.element, a), b
    }, htmlGetBBox: function () {
        var a = this, b = a.element;
        return"text" === b.nodeName && (b.style.position = Pa), {x: b.offsetLeft, y: b.offsetTop, width: b.offsetWidth, height: b.offsetHeight}
    }, htmlUpdateTransform: function () {
        if (!this.added)return void(this.alignOnAdd = !0);
        var a = this, c = a.renderer, d = a.element, e = a.translateX || 0, f = a.translateY || 0, g = a.x || 0, h = a.y || 0, i = a.textAlign || "left", k = {left: 0, center: .5, right: 1}[i], l = a.shadows, n = a.styles;
        if (m(d, {marginLeft: e, marginTop: f}), l && lb(l, function (a) {
            m(a, {marginLeft: e + 1, marginTop: f + 1})
        }), a.inverted && lb(d.childNodes, function (a) {
            c.invertChild(a, d)
        }), "SPAN" === d.tagName) {
            var o, p, q = a.rotation, r = b(a.textWidth), s = [q, i, d.innerHTML, a.textWidth, a.textAlign].join(",");
            s !== a.cTT && (p = c.fontMetrics(d.style.fontSize).b, j(q) && a.setSpanRotation(q, k, p), o = eb(a.elemWidth, d.offsetWidth), o > r && /[ \-]/.test(d.textContent || d.innerText) && (m(d, {width: r + Ua, display: "block", whiteSpace: n && n.whiteSpace || "normal"}), o = r), a.getSpanCorrection(o, p, k, q, i)), m(d, {left: g + (a.xCorr || 0) + Ua, top: h + (a.yCorr || 0) + Ua}), Aa && (p = d.offsetHeight), a.cTT = s
        }
    }, setSpanRotation: function (a, b, c) {
        var d = {}, e = ya ? "-ms-transform" : Aa ? "-webkit-transform" : Ba ? "MozTransform" : xa ? "-o-transform" : "";
        d[e] = d.transform = "rotate(" + a + "deg)", d[e + (Ba ? "Origin" : "-origin")] = d.transformOrigin = 100 * b + "% " + c + "px", m(this.element, d)
    }, getSpanCorrection: function (a, b, c) {
        this.xCorr = -a * c, this.yCorr = -b
    }}), db(Bb.prototype, {html: function (a, b, c) {
        var d = this.createElement("span"), e = d.element, f = d.renderer;
        return d.textSetter = function (a) {
            a !== e.innerHTML && delete this.bBox, e.innerHTML = this.textStr = a, d.htmlUpdateTransform()
        }, d.xSetter = d.ySetter = d.alignSetter = d.rotationSetter = function (a, b) {
            "align" === b && (b = "textAlign"), d[b] = a, d.htmlUpdateTransform()
        }, d.attr({text: a, x: ma(b), y: ma(c)}).css({position: Pa, fontFamily: this.style.fontFamily, fontSize: this.style.fontSize}), e.style.whiteSpace = "nowrap", d.css = d.htmlCss, f.isSVG && (d.add = function (a) {
            var b, c, g = f.box.parentNode, h = [];
            if (this.parentGroup = a, a) {
                if (b = a.div, !b) {
                    for (c = a; c;)h.push(c), c = c.parentGroup;
                    lb(h.reverse(), function (a) {
                        var c, d = k(a.element, "class");
                        d && (d = {className: d}), b = a.div = a.div || n(Oa, d, {position: Pa, left: (a.translateX || 0) + Ua, top: (a.translateY || 0) + Ua}, b || g), c = b.style, db(a, {translateXSetter: function (b, d) {
                            c.left = b + Ua, a[d] = b, a.doTransform = !0
                        }, translateYSetter: function (b, d) {
                            c.top = b + Ua, a[d] = b, a.doTransform = !0
                        }}), lb(["opacity", "visibility"], function (b) {
                            fb(a, b + "Setter", function (a, b, d, e) {
                                a.call(this, b, d, e), c[d] = b
                            })
                        })
                    })
                }
            } else b = g;
            return b.appendChild(e), d.added = !0, d.alignOnAdd && d.htmlUpdateTransform(), d
        }), d
    }});
    var Cb, Db;
    if (!Ea && !Ga) {
        Db = {init: function (a, b) {
            var c = this, d = ["<", b, ' filled="f" stroked="f"'], e = ["position: ", Pa, ";"], f = b === Oa;
            ("shape" === b || f) && e.push("left:0;top:0;width:1px;height:1px;"), e.push("visibility: ", f ? Ra : Ta), d.push(' style="', e.join(""), '"/>'), b && (d = f || "span" === b || "img" === b ? d.join("") : a.prepVML(d), c.element = n(d)), c.renderer = a
        }, add: function (a) {
            var b = this, c = b.renderer, d = b.element, e = c.box, f = a && a.inverted, g = a ? a.element || a : e;
            return f && c.invertChild(d, g), g.appendChild(d), b.added = !0, b.alignOnAdd && !b.deferUpdateTransform && b.updateTransform(), b.onAdd && b.onAdd(), b
        }, updateTransform: H.prototype.htmlUpdateTransform, setSpanRotation: function () {
            var a = this.rotation, b = sa(a * va), c = ta(a * va);
            m(this.element, {filter: a ? ["progid:DXImageTransform.Microsoft.Matrix(M11=", b, ", M12=", -c, ", M21=", c, ", M22=", b, ", sizingMethod='auto expand')"].join("") : Va})
        }, getSpanCorrection: function (a, b, c, d, e) {
            var f, g = d ? sa(d * va) : 1, h = d ? ta(d * va) : 0, i = eb(this.elemHeight, this.element.offsetHeight), j = e && "left" !== e;
            this.xCorr = 0 > g && -a, this.yCorr = 0 > h && -i, f = 0 > g * h, this.xCorr += h * b * (f ? 1 - c : c), this.yCorr -= g * b * (d ? f ? c : 1 - c : 1), j && (this.xCorr -= a * c * (0 > g ? -1 : 1), d && (this.yCorr -= i * c * (0 > h ? -1 : 1)), m(this.element, {textAlign: e}))
        }, pathToVML: function (a) {
            for (var b = a.length, c = []; b--;)f(a[b]) ? c[b] = ma(10 * a[b]) - 5 : "Z" === a[b] ? c[b] = "x" : (c[b] = a[b], !a.isArc || "wa" !== a[b] && "at" !== a[b] || (c[b + 5] === c[b + 7] && (c[b + 7] += a[b + 7] > a[b + 5] ? 1 : -1), c[b + 6] === c[b + 8] && (c[b + 8] += a[b + 8] > a[b + 6] ? 1 : -1)));
            return c.join(" ") || "x"
        }, clip: function (a) {
            var b, c, d = this;
            return a ? (b = a.members, i(b, d), b.push(d), d.destroyClip = function () {
                i(b, d)
            }, c = a.getCSS(d)) : (d.destroyClip && d.destroyClip(), c = {clip: za ? "inherit" : "rect(auto)"}), d.css(c)
        }, css: H.prototype.htmlCss, safeRemoveChild: function (a) {
            a.parentNode && A(a)
        }, destroy: function () {
            return this.destroyClip && this.destroyClip(), H.prototype.destroy.apply(this)
        }, on: function (a, b) {
            return this.element["on" + a] = function () {
                var a = ka.event;
                a.target = a.srcElement, b(a)
            }, this
        }, cutOffPath: function (a, c) {
            var d;
            return a = a.split(/[ ,]/), d = a.length, (9 === d || 11 === d) && (a[d - 4] = a[d - 2] = b(a[d - 2]) - 10 * c), a.join(" ")
        }, shadow: function (a, c, d) {
            var e, f, g, h, i, j, k, l = [], m = this.element, o = this.renderer, p = m.style, q = m.path;
            if (q && "string" != typeof q.value && (q = "x"), i = q, a) {
                for (j = eb(a.width, 3), k = (a.opacity || .15) / j, e = 1; 3 >= e; e++)h = 2 * j + 1 - 2 * e, d && (i = this.cutOffPath(q.value, h + .5)), g = ['<shape isShadow="true" strokeweight="', h, '" filled="false" path="', i, '" coordsize="10 10" style="', m.style.cssText, '" />'], f = n(o.prepVML(g), null, {left: b(p.left) + eb(a.offsetX, 1), top: b(p.top) + eb(a.offsetY, 1)}), d && (f.cutOff = h + 1), g = ['<stroke color="', a.color || "black", '" opacity="', k * e, '"/>'], n(o.prepVML(g), null, null, f), c ? c.element.appendChild(f) : m.parentNode.insertBefore(f, m), l.push(f);
                this.shadows = l
            }
            return this
        }, updateShadows: Ja, setAttr: function (a, b) {
            za ? this.element[a] = b : this.element.setAttribute(a, b)
        }, classSetter: function (a) {
            this.element.className = a
        }, dashstyleSetter: function (a, b, c) {
            var d = c.getElementsByTagName("stroke")[0] || n(this.renderer.prepVML(["<stroke/>"]), null, null, c);
            d[b] = a || "solid", this[b] = a
        }, dSetter: function (a, b, c) {
            var d, e = this.shadows;
            if (a = a || [], this.d = a.join && a.join(" "), c.path = a = this.pathToVML(a), e)for (d = e.length; d--;)e[d].path = e[d].cutOff ? this.cutOffPath(a, e[d].cutOff) : a;
            this.setAttr(b, a)
        }, fillSetter: function (a, b, c) {
            var d = c.nodeName;
            "SPAN" === d ? c.style.color = a : "IMG" !== d && (c.filled = a !== Va, this.setAttr("fillcolor", this.renderer.color(a, c, b, this)))
        }, opacitySetter: Ja, rotationSetter: function (a, b, c) {
            var d = c.style;
            this[b] = d[b] = a, d.left = -ma(ta(a * va) + 1) + Ua, d.top = ma(sa(a * va)) + Ua
        }, strokeSetter: function (a, b, c) {
            this.setAttr("strokecolor", this.renderer.color(a, c, b))
        }, "stroke-widthSetter": function (a, b, c) {
            c.stroked = !!a, this[b] = a, f(a) && (a += Ua), this.setAttr("strokeweight", a)
        }, titleSetter: function (a, b) {
            this.setAttr(b, a)
        }, visibilitySetter: function (a, b, c) {
            "inherit" === a && (a = Ta), this.shadows && lb(this.shadows, function (c) {
                c.style[b] = a
            }), "DIV" === c.nodeName && (a = a === Ra ? "-999em" : 0, za || (c.style[b] = a ? Ta : Ra), b = "top"), c.style[b] = a
        }, xSetter: function (a, b, c) {
            this[b] = a, "x" === b ? b = "left" : "y" === b && (b = "top"), this.updateClipping ? (this[b] = a, this.updateClipping()) : c.style[b] = a
        }, zIndexSetter: function (a, b, c) {
            c.style[b] = a
        }}, ia.VMLElement = Db = o(H, Db), Db.prototype.ySetter = Db.prototype.widthSetter = Db.prototype.heightSetter = Db.prototype.xSetter;
        var Eb = {Element: Db, isIE8: wa.indexOf("MSIE 8.0") > -1, init: function (a, b, c, d) {
            var e, f, g, h = this;
            if (h.alignedObjects = [], e = h.createElement(Oa).css(db(this.getStyle(d), {position: Qa})), f = e.element, a.appendChild(e.element), h.isVML = !0, h.box = f, h.boxWrapper = e, h.cache = {}, h.setSize(b, c, !1), !ja.namespaces.hcv) {
                ja.namespaces.add("hcv", "urn:schemas-microsoft-com:vml"), g = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } ";
                try {
                    ja.createStyleSheet().cssText = g
                } catch (i) {
                    ja.styleSheets[0].cssText += g
                }
            }
        }, isHidden: function () {
            return!this.box.offsetWidth
        }, clipRect: function (a, b, c, e) {
            var f = this.createElement(), g = d(a);
            return db(f, {members: [], count: 0, left: (g ? a.x : a) + 1, top: (g ? a.y : b) + 1, width: (g ? a.width : c) - 1, height: (g ? a.height : e) - 1, getCSS: function (a) {
                var b = a.element, c = b.nodeName, d = "shape" === c, e = a.inverted, f = this, g = f.top - (d ? b.offsetTop : 0), h = f.left, i = h + f.width, j = g + f.height, k = {clip: "rect(" + ma(e ? h : g) + "px," + ma(e ? j : i) + "px," + ma(e ? i : j) + "px," + ma(e ? g : h) + "px)"};
                return!e && za && "DIV" === c && db(k, {width: i + Ua, height: j + Ua}), k
            }, updateClipping: function () {
                lb(f.members, function (a) {
                    a.element && a.css(f.getCSS(a))
                })
            }})
        }, color: function (a, b, c, d) {
            var e, f, g, h = this, i = /^rgba/, j = Va;
            if (a && a.linearGradient ? g = "gradient" : a && a.radialGradient && (g = "pattern"), g) {
                var k, l, m, o, p, q, r, s, t, u, v, w, x = a.linearGradient || a.radialGradient, y = "", z = a.stops, A = [], B = function () {
                    f = ['<fill colors="' + A.join(",") + '" opacity="', s, '" o:opacity2="', r, '" type="', g, '" ', y, 'focus="100%" method="any" />'], n(h.prepVML(f), null, null, b)
                };
                if (v = z[0], w = z[z.length - 1], v[0] > 0 && z.unshift([0, v[1]]), w[0] < 1 && z.push([1, w[1]]), lb(z, function (a, b) {
                    i.test(a[1]) ? (e = Ab(a[1]), k = e.get("rgb"), l = e.get("a")) : (k = a[1], l = 1), A.push(100 * a[0] + "% " + k), b ? (s = l, t = k) : (r = l, u = k)
                }), "fill" === c)if ("gradient" === g)m = x.x1 || x[0] || 0, o = x.y1 || x[1] || 0, p = x.x2 || x[2] || 0, q = x.y2 || x[3] || 0, y = 'angle="' + (90 - 180 * la.atan((q - o) / (p - m)) / ua) + '"', B(); else {
                    var C, D = x.r, E = 2 * D, F = 2 * D, G = x.cx, H = x.cy, I = b.radialReference, J = function () {
                        I && (C = d.getBBox(), G += (I[0] - C.x) / C.width - .5, H += (I[1] - C.y) / C.height - .5, E *= I[2] / C.width, F *= I[2] / C.height), y = 'src="' + O.global.VMLRadialGradientURL + '" size="' + E + "," + F + '" origin="0.5,0.5" position="' + G + "," + H + '" color2="' + u + '" ', B()
                    };
                    d.added ? J() : d.onAdd = J, j = t
                } else j = k
            } else if (i.test(a) && "IMG" !== b.tagName)e = Ab(a), f = ["<", c, ' opacity="', e.get("a"), '"/>'], n(this.prepVML(f), null, null, b), j = e.get("rgb"); else {
                var K = b.getElementsByTagName(c);
                K.length && (K[0].opacity = 1, K[0].type = "solid"), j = a
            }
            return j
        }, prepVML: function (a) {
            var b = "display:inline-block;behavior:url(#default#VML);", c = this.isIE8;
            return a = a.join(""), c ? (a = a.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />'), a = -1 === a.indexOf('style="') ? a.replace("/>", ' style="' + b + '" />') : a.replace('style="', 'style="' + b)) : a = a.replace("<", "<hcv:"), a
        }, text: Bb.prototype.html, path: function (a) {
            var b = {coordsize: "10 10"};
            return e(a) ? b.d = a : d(a) && db(b, a), this.createElement("shape").attr(b)
        }, circle: function (a, b, c) {
            var e = this.symbol("circle");
            return d(a) && (c = a.r, b = a.y, a = a.x), e.isCircle = !0, e.r = c, e.attr({x: a, y: b})
        }, g: function (a) {
            var b, c;
            return a && (c = {className: Sa + a, "class": Sa + a}), b = this.createElement(Oa).attr(c)
        }, image: function (a, b, c, d, e) {
            var f = this.createElement("img").attr({src: a});
            return arguments.length > 1 && f.attr({x: b, y: c, width: d, height: e}), f
        }, createElement: function (a) {
            return"rect" === a ? this.symbol(a) : Bb.prototype.createElement.call(this, a)
        }, invertChild: function (a, c) {
            var d = this, e = c.style, f = "IMG" === a.tagName && a.style;
            m(a, {flip: "x", left: b(e.width) - (f ? b(f.top) : 1), top: b(e.height) - (f ? b(f.left) : 1), rotation: -90}), lb(a.childNodes, function (b) {
                d.invertChild(b, a)
            })
        }, symbols: {arc: function (a, b, c, d, e) {
            var f, g = e.start, h = e.end, i = e.r || c || d, j = e.innerR, k = sa(g), l = ta(g), m = sa(h), n = ta(h);
            return h - g === 0 ? ["x"] : (f = ["wa", a - i, b - i, a + i, b + i, a + i * k, b + i * l, a + i * m, b + i * n], e.open && !j && f.push("e", Wa, a, b), f.push("at", a - j, b - j, a + j, b + j, a + j * m, b + j * n, a + j * k, b + j * l, "x", "e"), f.isArc = !0, f)
        }, circle: function (a, b, c, d, e) {
            return e && (c = d = 2 * e.r), e && e.isCircle && (a -= c / 2, b -= d / 2), ["wa", a, b, a + c, b + d, a + c, b + d / 2, a + c, b + d / 2, "e"]
        }, rect: function (a, b, c, d, e) {
            return Bb.prototype.symbols[j(e) && e.r ? "callout" : "square"].call(0, a, b, c, d, e)
        }}};
        ia.VMLRenderer = Cb = function () {
            this.init.apply(this, arguments)
        }, Cb.prototype = a(Bb.prototype, Eb), L = Cb
    }
    Bb.prototype.measureSpanWidth = function (a, b) {
        var c, d = ja.createElement("span"), e = ja.createTextNode(a);
        return d.appendChild(e), m(d, b), this.box.appendChild(d), c = d.offsetWidth, A(d), c
    };
    var Fb, Gb;
    Ga && (ia.CanVGRenderer = Fb = function () {
        Da = "http://www.w3.org/1999/xhtml"
    }, Fb.prototype.symbols = {}, Gb = function () {
        function a() {
            var a, c = b.length;
            for (a = 0; c > a; a++)b[a]();
            b = []
        }

        var b = [];
        return{push: function (c, d) {
            0 === b.length && jb(d, a), b.push(c)
        }}
    }(), L = Fb), I.prototype = {addLabel: function () {
        var b, c, d = this, e = d.axis, f = e.options, g = e.chart, i = e.categories, k = e.names, l = d.pos, m = f.labels, n = e.tickPositions, o = l === n[0], p = l === n[n.length - 1], q = i ? eb(i[l], k[l], l) : l, r = d.label, s = n.info;
        e.isDatetimeAxis && s && (c = f.dateTimeLabelFormats[s.higherRanks[l] || s.unitName]), d.isFirst = o, d.isLast = p, b = e.labelFormatter.call({axis: e, chart: g, isFirst: o, isLast: p, dateTimeLabelFormat: c, value: e.isLog ? C(h(q)) : q}), j(r) ? r && r.attr({text: b}) : (d.label = r = j(b) && m.enabled ? g.renderer.text(b, 0, 0, m.useHTML).css(a(m.style)).add(e.labelGroup) : null, d.labelLength = r && r.getBBox().width, d.rotation = 0)
    }, getLabelSize: function () {
        return this.label ? this.label.getBBox()[this.axis.horiz ? "height" : "width"] : 0
    }, handleOverflow: function (a) {
        var b, c, d, e = this.axis, f = a.x, g = e.chart.chartWidth, h = e.chart.spacing, i = eb(e.labelLeft, qa(e.pos, h[3])), j = eb(e.labelRight, pa(e.pos + e.len, g - h[1])), k = this.label, l = this.rotation, m = {left: 0, center: .5, right: 1}[e.labelAlign], n = k.getBBox().width, o = e.slotWidth, p = m, q = 1, r = {};
        l ? 0 > l && i > f - m * n ? d = ma(f / sa(l * va) - i) : l > 0 && f + m * n > j && (d = ma((g - f) / sa(l * va))) : (b = f - m * n, c = f + (1 - m) * n, i > b ? o = a.x + o * (1 - m) - i : c > j && (o = j - a.x + o * m, q = -1), o = qa(e.slotWidth, o), o < e.slotWidth && "center" === e.labelAlign && (a.x += q * (e.slotWidth - o - p * (e.slotWidth - qa(n, o)))), (n > o || e.autoRotation && k.styles.width) && (d = o)), d && (r.width = d, e.options.labels.style.textOverflow || (r.textOverflow = "ellipsis"), k.css(r))
    }, getPosition: function (a, b, c, d) {
        var e = this.axis, f = e.chart, g = d && f.oldChartHeight || f.chartHeight;
        return{x: a ? e.translate(b + c, null, null, d) + e.transB : e.left + e.offset + (e.opposite ? (d && f.oldChartWidth || f.chartWidth) - e.right - e.left : 0), y: a ? g - e.bottom + e.offset - (e.opposite ? e.height : 0) : g - e.translate(b + c, null, null, d) - e.transB}
    }, getLabelPosition: function (a, b, c, d, e, f, g, h) {
        var i, j = this.axis, k = j.transA, l = j.reversed, m = j.staggerLines, n = j.tickRotCorr || {x: 0, y: 0}, o = eb(e.y, n.y + (2 === j.side ? 8 : -(c.getBBox().height / 2)));
        return a = a + e.x + n.x - (f && d ? f * k * (l ? -1 : 1) : 0), b = b + o - (f && !d ? f * k * (l ? 1 : -1) : 0), m && (i = g / (h || 1) % m, b += i * (j.labelOffset / m)), {x: a, y: ma(b)}
    }, getMarkPath: function (a, b, c, d, e, f) {
        return f.crispLine([Wa, a, b, Xa, a + (e ? 0 : -c), b + (e ? c : 0)], d)
    }, render: function (a, b, c) {
        var d, e, f, g = this, h = g.axis, i = h.options, j = h.chart, k = j.renderer, l = h.horiz, m = g.type, n = g.label, o = g.pos, p = i.labels, q = g.gridLine, r = m ? m + "Grid" : "grid", s = m ? m + "Tick" : "tick", t = i[r + "LineWidth"], u = i[r + "LineColor"], v = i[r + "LineDashStyle"], w = i[s + "Length"], x = eb(i[s + "Width"], !m && h.isXAxis ? 1 : 0), y = i[s + "Color"], z = i[s + "Position"], A = g.mark, B = p.step, C = !0, D = h.tickmarkOffset, E = g.getPosition(l, o, D, b), F = E.x, G = E.y, H = l && F === h.pos + h.len || !l && G === h.pos ? -1 : 1;
        c = eb(c, 1), this.isActive = !0, t && (d = h.getPlotLinePath(o + D, t * H, b, !0), q === K && (f = {stroke: u, "stroke-width": t}, v && (f.dashstyle = v), m || (f.zIndex = 1), b && (f.opacity = 0), g.gridLine = q = t ? k.path(d).attr(f).add(h.gridGroup) : null), !b && q && d && q[g.isNew ? "attr" : "animate"]({d: d, opacity: c})), x && w && ("inside" === z && (w = -w), h.opposite && (w = -w), e = g.getMarkPath(F, G, w, x * H, l, k), A ? A.animate({d: e, opacity: c}) : g.mark = k.path(e).attr({stroke: y, "stroke-width": x, opacity: c}).add(h.axisGroup)), n && !isNaN(F) && (n.xy = E = g.getLabelPosition(F, G, n, l, p, D, a, B), g.isFirst && !g.isLast && !eb(i.showFirstLabel, 1) || g.isLast && !g.isFirst && !eb(i.showLastLabel, 1) ? C = !1 : !l || h.isRadial || p.step || p.rotation || b || 0 === c || g.handleOverflow(E), B && a % B && (C = !1), C && !isNaN(E.y) ? (E.opacity = c, n[g.isNew ? "attr" : "animate"](E), g.isNew = !1) : n.attr("y", -9999))
    }, destroy: function () {
        z(this, this.axis)
    }}, ia.PlotLineOrBand = function (a, b) {
        this.axis = a, b && (this.options = b, this.id = b.id)
    }, ia.PlotLineOrBand.prototype = {render: function () {
        var b, c, d, e, f, h, i = this, k = i.axis, l = k.horiz, m = i.options, n = m.label, o = i.label, p = m.width, q = m.to, r = m.from, s = j(r) && j(q), t = m.value, u = m.dashStyle, v = i.svgElem, w = [], z = m.color, A = m.zIndex, B = m.events, C = {}, D = k.chart.renderer;
        if (k.isLog && (r = g(r), q = g(q), t = g(t)), p)w = k.getPlotLinePath(t, p), C = {stroke: z, "stroke-width": p}, u && (C.dashstyle = u); else {
            if (!s)return;
            w = k.getPlotBandPath(r, q, m), z && (C.fill = z), m.borderWidth && (C.stroke = m.borderColor, C["stroke-width"] = m.borderWidth)
        }
        if (j(A) && (C.zIndex = A), v)w ? v.animate({d: w}, null, v.onGetPath) : (v.hide(), v.onGetPath = function () {
            v.show()
        }, o && (i.label = o = o.destroy())); else if (w && w.length && (i.svgElem = v = D.path(w).attr(C).add(), B)) {
            b = function (a) {
                v.on(a, function (b) {
                    B[a].apply(i, [b])
                })
            };
            for (c in B)b(c)
        }
        return n && j(n.text) && w && w.length && k.width > 0 && k.height > 0 ? (n = a({align: l && s && "center", x: l ? !s && 4 : 10, verticalAlign: !l && s && "middle", y: l ? s ? 16 : 10 : s ? 6 : -4, rotation: l && !s && 90}, n), o || (C = {align: n.textAlign || n.align, rotation: n.rotation}, j(A) && (C.zIndex = A), i.label = o = D.text(n.text, 0, 0, n.useHTML).attr(C).css(n.style).add()), d = [w[1], w[4], s ? w[6] : w[1]], e = [w[2], w[5], s ? w[7] : w[2]], f = x(d), h = x(e), o.align(n, !1, {x: f, y: h, width: y(d) - f, height: y(e) - h}), o.show()) : o && o.hide(), i
    }, destroy: function () {
        i(this.axis.plotLinesAndBands, this), delete this.axis, z(this)
    }}, S = {getPlotBandPath: function (a, b) {
        var c = this.getPlotLinePath(b, null, null, !0), d = this.getPlotLinePath(a, null, null, !0);
        return d && c && d.toString() !== c.toString() ? d.push(c[4], c[5], c[1], c[2]) : d = null, d
    }, addPlotBand: function (a) {
        return this.addPlotBandOrLine(a, "plotBands")
    }, addPlotLine: function (a) {
        return this.addPlotBandOrLine(a, "plotLines")
    }, addPlotBandOrLine: function (a, b) {
        var c = new ia.PlotLineOrBand(this, a).render(), d = this.userOptions;
        return c && (b && (d[b] = d[b] || [], d[b].push(a)), this.plotLinesAndBands.push(c)), c
    }, removePlotBandOrLine: function (a) {
        for (var b = this.plotLinesAndBands, c = this.options, d = this.userOptions, e = b.length; e--;)b[e].id === a && b[e].destroy();
        lb([c.plotLines || [], d.plotLines || [], c.plotBands || [], d.plotBands || []], function (b) {
            for (e = b.length; e--;)b[e].id === a && i(b, b[e])
        })
    }};
    var Hb = ia.Axis = function () {
        this.init.apply(this, arguments)
    };
    Hb.prototype = {defaultOptions: {dateTimeLabelFormats: {millisecond: "%H:%M:%S.%L", second: "%H:%M:%S", minute: "%H:%M", hour: "%H:%M", day: "%e. %b", week: "%e. %b", month: "%b '%y", year: "%Y"}, endOnTick: !1, gridLineColor: "#D8D8D8", labels: {enabled: !0, style: {color: "#606060", cursor: "default", fontSize: "11px"}, x: 0, y: 15}, lineColor: "#C0D0E0", lineWidth: 1, minPadding: .01, maxPadding: .01, minorGridLineColor: "#E0E0E0", minorGridLineWidth: 1, minorTickColor: "#A0A0A0", minorTickLength: 2, minorTickPosition: "outside", startOfWeek: 1, startOnTick: !1, tickColor: "#C0D0E0", tickLength: 10, tickmarkPlacement: "between", tickPixelInterval: 100, tickPosition: "outside", title: {align: "middle", style: {color: "#707070"}}, type: "linear"}, defaultYAxisOptions: {endOnTick: !0, gridLineWidth: 1, tickPixelInterval: 72, showLastLabel: !0, labels: {x: -8, y: 3}, lineWidth: 0, maxPadding: .05, minPadding: .05, startOnTick: !0, title: {rotation: 270, text: "Values"}, stackLabels: {enabled: !1, formatter: function () {
        return ia.numberFormat(this.total, -1)
    }, style: a(vb.line.dataLabels.style, {color: "#000000"})}}, defaultLeftAxisOptions: {labels: {x: -15, y: null}, title: {rotation: 270}}, defaultRightAxisOptions: {labels: {x: 15, y: null}, title: {rotation: 90}}, defaultBottomAxisOptions: {labels: {autoRotation: [-45], x: 0, y: null}, title: {rotation: 0}}, defaultTopAxisOptions: {labels: {autoRotation: [-45], x: 0, y: -15}, title: {rotation: 0}}, init: function (a, b) {
        var c = b.isX, d = this;
        d.chart = a, d.horiz = a.inverted ? !c : c, d.isXAxis = c, d.coll = c ? "xAxis" : "yAxis", d.opposite = b.opposite, d.side = b.side || (d.horiz ? d.opposite ? 0 : 2 : d.opposite ? 1 : 3), d.setOptions(b);
        var e = this.options, f = e.type, i = "datetime" === f;
        d.labelFormatter = e.labels.formatter || d.defaultLabelFormatter, d.userOptions = b, d.minPixelPadding = 0, d.reversed = e.reversed, d.visible = e.visible !== !1, d.zoomEnabled = e.zoomEnabled !== !1, d.categories = e.categories || "category" === f, d.names = d.names || [], d.isLog = "logarithmic" === f, d.isDatetimeAxis = i, d.isLinked = j(e.linkedTo), d.ticks = {}, d.labelEdge = [], d.minorTicks = {}, d.plotLinesAndBands = [], d.alternateBands = {}, d.len = 0, d.minRange = d.userMinRange = e.minRange || e.maxZoom, d.range = e.range, d.offset = e.offset || 0, d.stacks = {}, d.oldStacks = {}, d.stacksTouched = 0, d.max = null, d.min = null, d.crosshair = eb(e.crosshair, l(a.options.tooltip.crosshairs)[c ? 0 : 1], !1);
        var k, m = d.options.events;
        -1 === kb(d, a.axes) && (c && !this.isColorAxis ? a.axes.splice(a.xAxis.length, 0, d) : a.axes.push(d), a[d.coll].push(d)), d.series = d.series || [], a.inverted && c && d.reversed === K && (d.reversed = !0), d.removePlotBand = d.removePlotBandOrLine, d.removePlotLine = d.removePlotBandOrLine;
        for (k in m)pb(d, k, m[k]);
        d.isLog && (d.val2lin = g, d.lin2val = h)
    }, setOptions: function (b) {
        this.options = a(this.defaultOptions, this.isXAxis ? {} : this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], a(O[this.coll], b))
    }, defaultLabelFormatter: function () {
        var a, b, c = this.axis, d = this.value, e = c.categories, f = this.dateTimeLabelFormat, g = O.lang.numericSymbols, h = g && g.length, i = c.options.labels.format, j = c.isLog ? d : c.tickInterval;
        if (i)b = t(i, this); else if (e)b = d; else if (f)b = P(f, d); else if (h && j >= 1e3)for (; h-- && b === K;)a = Math.pow(1e3, h + 1), j >= a && 10 * d % a === 0 && null !== g[h] && (b = ia.numberFormat(d / a, -1) + g[h]);
        return b === K && (b = ra(d) >= 1e4 ? ia.numberFormat(d, -1) : ia.numberFormat(d, -1, K, "")), b
    }, getSeriesExtremes: function () {
        var a = this, b = a.chart;
        a.hasVisibleSeries = !1, a.dataMin = a.dataMax = a.threshold = null, a.softThreshold = !a.isXAxis, a.buildStacks && a.buildStacks(), lb(a.series, function (c) {
            if (c.visible || !b.options.chart.ignoreHiddenSeries) {
                var d, e, f, g = c.options, h = g.threshold;
                a.hasVisibleSeries = !0, a.isLog && 0 >= h && (h = null), a.isXAxis ? (d = c.xData, d.length && (a.dataMin = qa(eb(a.dataMin, d[0]), x(d)), a.dataMax = pa(eb(a.dataMax, d[0]), y(d)))) : (c.getExtremes(), f = c.dataMax, e = c.dataMin, j(e) && j(f) && (a.dataMin = qa(eb(a.dataMin, e), e), a.dataMax = pa(eb(a.dataMax, f), f)), j(h) && (a.threshold = h), (!g.softThreshold || a.isLog) && (a.softThreshold = !1))
            }
        })
    }, translate: function (a, b, c, d, e, g) {
        var h, i = this.linkedParent || this, j = 1, k = 0, l = d ? i.oldTransA : i.transA, m = d ? i.oldMin : i.min, n = i.minPixelPadding, o = (i.doPostTranslate || i.isLog && e) && i.lin2val;
        return l || (l = i.transA), c && (j *= -1, k = i.len), i.reversed && (j *= -1, k -= j * (i.sector || i.len)), b ? (a = a * j + k, a -= n, h = a / l + m, o && (h = i.lin2val(h))) : (o && (a = i.val2lin(a)), "between" === g && (g = .5), h = j * (a - m) * l + k + j * n + (f(g) ? l * g * i.pointRange : 0)), h
    }, toPixels: function (a, b) {
        return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos)
    }, toValue: function (a, b) {
        return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0)
    }, getPlotLinePath: function (a, b, c, d, e) {
        var f, g, h, i, j, k = this, l = k.chart, m = k.left, n = k.top, o = c && l.oldChartHeight || l.chartHeight, p = c && l.oldChartWidth || l.chartWidth, q = k.transB, r = function (a, b, c) {
            return(b > a || a > c) && (d ? a = qa(pa(b, a), c) : j = !0), a
        };
        return e = eb(e, k.translate(a, null, null, c)), f = h = ma(e + q), g = i = ma(o - e - q), isNaN(e) ? j = !0 : k.horiz ? (g = n, i = o - k.bottom, f = h = r(f, m, m + k.width)) : (f = m, h = p - k.right, g = i = r(g, n, n + k.height)), j && !d ? null : l.renderer.crispLine([Wa, f, g, Xa, h, i], b || 1)
    }, getLinearTickPositions: function (a, b, c) {
        var d, e, g = C(na(b / a) * a), h = C(oa(c / a) * a), i = [];
        if (b === c && f(b))return[b];
        for (d = g; h >= d && (i.push(d), d = C(d + a), d !== e);)e = d;
        return i
    }, getMinorTickPositions: function () {
        var a, b, c, d = this, e = d.options, f = d.tickPositions, g = d.minorTickInterval, h = [], i = d.pointRangePadding || 0, j = d.min - i, k = d.max + i, l = k - j;
        if (l && l / g < d.len / 3)if (d.isLog)for (c = f.length, b = 1; c > b; b++)h = h.concat(d.getLogTickPositions(g, f[b - 1], f[b], !0)); else if (d.isDatetimeAxis && "auto" === e.minorTickInterval)h = h.concat(d.getTimeTicks(d.normalizeTimeTickInterval(g), j, k, e.startOfWeek)); else for (a = j + (f[0] - j) % g; k >= a; a += g)h.push(a);
        return 0 !== h.length && d.trimTicks(h, e.startOnTick, e.endOnTick), h
    }, adjustForMinRange: function () {
        var a, b, c, d, e, f, g, h, i, k = this, l = k.options, m = k.min, n = k.max, o = k.dataMax - k.dataMin >= k.minRange;
        k.isXAxis && k.minRange === K && !k.isLog && (j(l.min) || j(l.max) ? k.minRange = null : (lb(k.series, function (a) {
            for (e = a.xData, f = a.xIncrement ? 1 : e.length - 1, c = f; c > 0; c--)d = e[c] - e[c - 1], (b === K || b > d) && (b = d)
        }), k.minRange = qa(5 * b, k.dataMax - k.dataMin))), n - m < k.minRange && (i = k.minRange, a = (i - n + m) / 2, g = [m - a, eb(l.min, m - a)], o && (g[2] = k.dataMin), m = y(g), h = [m + i, eb(l.max, m + i)], o && (h[2] = k.dataMax), n = x(h), i > n - m && (g[0] = n - i, g[1] = eb(l.min, n - i), m = y(g))), k.min = m, k.max = n
    }, setAxisTranslation: function (a) {
        var b, d, e = this, f = e.max - e.min, g = e.axisPointRange || 0, h = 0, i = 0, k = e.linkedParent, l = !!e.categories, m = e.transA, n = e.isXAxis;
        (n || l || g) && (k ? (h = k.minPointOffset, i = k.pointRangePadding) : lb(e.series, function (a) {
            var d = l ? 1 : n ? a.pointRange : e.axisPointRange || 0, f = a.options.pointPlacement, k = a.closestPointRange;
            g = pa(g, d), e.single || (h = pa(h, c(f) ? 0 : d / 2), i = pa(i, "on" === f ? 0 : d)), !a.noSharedTooltip && j(k) && (b = j(b) ? qa(b, k) : k)
        }), d = e.ordinalSlope && b ? e.ordinalSlope / b : 1, e.minPointOffset = h *= d, e.pointRangePadding = i *= d, e.pointRange = qa(g, f), n && (e.closestPointRange = b)), a && (e.oldTransA = m), e.translationSlope = e.transA = m = e.len / (f + i || 1), e.transB = e.horiz ? e.left : e.bottom, e.minPixelPadding = m * h
    }, minFromRange: function () {
        return this.max - this.range
    }, setTickInterval: function (a) {
        var b, c, d, e, h, i, k, l = this, m = l.chart, n = l.options, o = l.isLog, p = l.isDatetimeAxis, q = l.isXAxis, r = l.isLinked, s = n.maxPadding, t = n.minPadding, w = n.tickInterval, x = n.tickPixelInterval, y = l.categories, z = l.threshold, A = l.softThreshold;
        p || y || r || this.getTickAmount(), i = eb(l.userMin, n.min), k = eb(l.userMax, n.max), r ? (l.linkedParent = m[l.coll][n.linkedTo], c = l.linkedParent.getExtremes(), l.min = eb(c.min, c.dataMin), l.max = eb(c.max, c.dataMax), n.type !== l.linkedParent.options.type && B(11, 1)) : (!A && j(z) && (l.dataMin >= z ? (e = z, t = 0) : l.dataMax <= z && (h = z, s = 0)), l.min = eb(i, e, l.dataMin), l.max = eb(k, h, l.dataMax)), o && (!a && qa(l.min, eb(l.dataMin, l.min)) <= 0 && B(10, 1), l.min = C(g(l.min), 15), l.max = C(g(l.max), 15)), l.range && j(l.max) && (l.userMin = l.min = i = pa(l.min, l.minFromRange()), l.userMax = k = l.max, l.range = null), l.beforePadding && l.beforePadding(), l.adjustForMinRange(), y || l.axisPointRange || l.usePercentage || r || !j(l.min) || !j(l.max) || (b = l.max - l.min, b && (!j(i) && t && (l.min -= b * t), !j(k) && s && (l.max += b * s))), f(n.floor) && (l.min = pa(l.min, n.floor)), f(n.ceiling) && (l.max = qa(l.max, n.ceiling)), A && j(l.dataMin) && (z = z || 0, !j(i) && l.min < z && l.dataMin >= z ? l.min = z : !j(k) && l.max > z && l.dataMax <= z && (l.max = z)), l.min === l.max || void 0 === l.min || void 0 === l.max ? l.tickInterval = 1 : r && !w && x === l.linkedParent.options.tickPixelInterval ? l.tickInterval = w = l.linkedParent.tickInterval : l.tickInterval = eb(w, this.tickAmount ? (l.max - l.min) / pa(this.tickAmount - 1, 1) : void 0, y ? 1 : (l.max - l.min) * x / pa(l.len, x)), q && !a && lb(l.series, function (a) {
            a.processData(l.min !== l.oldMin || l.max !== l.oldMax)
        }), l.setAxisTranslation(!0), l.beforeSetTickPositions && l.beforeSetTickPositions(), l.postProcessTickInterval && (l.tickInterval = l.postProcessTickInterval(l.tickInterval)), l.pointRange && (l.tickInterval = pa(l.pointRange, l.tickInterval)), d = eb(n.minTickInterval, l.isDatetimeAxis && l.closestPointRange), !w && l.tickInterval < d && (l.tickInterval = d), p || o || w || (l.tickInterval = v(l.tickInterval, null, u(l.tickInterval), eb(n.allowDecimals, !(l.tickInterval > .5 && l.tickInterval < 5 && l.max > 1e3 && l.max < 9999)), !!this.tickAmount)), !this.tickAmount && this.len && (l.tickInterval = l.unsquish()), this.setTickPositions()
    }, setTickPositions: function () {
        var a, b, c = this.options, d = c.tickPositions, e = c.tickPositioner, f = c.startOnTick, g = c.endOnTick;
        this.tickmarkOffset = this.categories && "between" === c.tickmarkPlacement && 1 === this.tickInterval ? .5 : 0, this.minorTickInterval = "auto" === c.minorTickInterval && this.tickInterval ? this.tickInterval / 5 : c.minorTickInterval, this.tickPositions = a = d && d.slice(), a || (a = this.isDatetimeAxis ? this.getTimeTicks(this.normalizeTimeTickInterval(this.tickInterval, c.units), this.min, this.max, c.startOfWeek, this.ordinalPositions, this.closestPointRange, !0) : this.isLog ? this.getLogTickPositions(this.tickInterval, this.min, this.max) : this.getLinearTickPositions(this.tickInterval, this.min, this.max), a.length > this.len && (a = [a[0], a.pop()]), this.tickPositions = a, e && (e = e.apply(this, [this.min, this.max]), e && (this.tickPositions = a = e))), this.isLinked || (this.trimTicks(a, f, g), this.min === this.max && j(this.min) && !this.tickAmount && (b = !0, this.min -= .5, this.max += .5), this.single = b, d || e || this.adjustTickAmount())
    }, trimTicks: function (a, b, c) {
        var d = a[0], e = a[a.length - 1], f = this.minPointOffset || 0;
        b ? this.min = d : this.min - f > d && a.shift(), c ? this.max = e : this.max + f < e && a.pop(), 0 === a.length && j(d) && a.push((e + d) / 2)
    }, getTickAmount: function () {
        var a, b = {}, c = this.options, d = c.tickAmount, e = c.tickPixelInterval;
        !j(c.tickInterval) && this.len < e && !this.isRadial && !this.isLog && c.startOnTick && c.endOnTick && (d = 2), d || this.chart.options.chart.alignTicks === !1 || c.alignTicks === !1 || (lb(this.chart[this.coll], function (c) {
            var d = c.options, e = c.horiz, f = [e ? d.left : d.top, e ? d.width : d.height, d.pane].join(",");
            c.series.length && (b[f] ? a = !0 : b[f] = 1)
        }), a && (d = oa(this.len / e) + 1)), 4 > d && (this.finalTickAmt = d, d = 5), this.tickAmount = d
    }, adjustTickAmount: function () {
        var a, b, c = this.tickInterval, d = this.tickPositions, e = this.tickAmount, f = this.finalTickAmt, g = d && d.length;
        if (e > g) {
            for (; d.length < e;)d.push(C(d[d.length - 1] + c));
            this.transA *= (g - 1) / (e - 1), this.max = d[d.length - 1]
        } else g > e && (this.tickInterval *= 2,
            this.setTickPositions());
        if (j(f)) {
            for (a = b = d.length; a--;)(3 === f && a % 2 === 1 || 2 >= f && a > 0 && b - 1 > a) && d.splice(a, 1);
            this.finalTickAmt = K
        }
    }, setScale: function () {
        var a, b, c = this;
        c.oldMin = c.min, c.oldMax = c.max, c.oldAxisLength = c.len, c.setAxisSize(), b = c.len !== c.oldAxisLength, lb(c.series, function (b) {
            (b.isDirtyData || b.isDirty || b.xAxis.isDirty) && (a = !0)
        }), b || a || c.isLinked || c.forceRedraw || c.userMin !== c.oldUserMin || c.userMax !== c.oldUserMax ? (c.resetStacks && c.resetStacks(), c.forceRedraw = !1, c.getSeriesExtremes(), c.setTickInterval(), c.oldUserMin = c.userMin, c.oldUserMax = c.userMax, c.isDirty || (c.isDirty = b || c.min !== c.oldMin || c.max !== c.oldMax)) : c.cleanStacks && c.cleanStacks()
    }, setExtremes: function (a, b, c, d, e) {
        var f = this, g = f.chart;
        c = eb(c, !0), lb(f.series, function (a) {
            delete a.kdTree
        }), e = db(e, {min: a, max: b}), rb(f, "setExtremes", e, function () {
            f.userMin = a, f.userMax = b, f.eventArgs = e, c && g.redraw(d)
        })
    }, zoom: function (a, b) {
        var c = this.dataMin, d = this.dataMax, e = this.options, f = qa(c, eb(e.min, c)), g = pa(d, eb(e.max, d));
        return this.allowZoomOutside || (j(c) && f >= a && (a = f), j(d) && b >= g && (b = g)), this.displayBtn = a !== K || b !== K, this.setExtremes(a, b, !1, K, {trigger: "zoom"}), !0
    }, setAxisSize: function () {
        var a = this.chart, b = this.options, c = b.offsetLeft || 0, d = b.offsetRight || 0, e = this.horiz, f = eb(b.width, a.plotWidth - c + d), g = eb(b.height, a.plotHeight), h = eb(b.top, a.plotTop), i = eb(b.left, a.plotLeft + c), j = /%$/;
        j.test(g) && (g = parseFloat(g) / 100 * a.plotHeight), j.test(h) && (h = parseFloat(h) / 100 * a.plotHeight + a.plotTop), this.left = i, this.top = h, this.width = f, this.height = g, this.bottom = a.chartHeight - g - h, this.right = a.chartWidth - f - i, this.len = pa(e ? f : g, 0), this.pos = e ? i : h
    }, getExtremes: function () {
        var a = this, b = a.isLog;
        return{min: b ? C(h(a.min)) : a.min, max: b ? C(h(a.max)) : a.max, dataMin: a.dataMin, dataMax: a.dataMax, userMin: a.userMin, userMax: a.userMax}
    }, getThreshold: function (a) {
        var b = this, c = b.isLog, d = c ? h(b.min) : b.min, e = c ? h(b.max) : b.max;
        return null === a ? a = 0 > e ? e : d : d > a ? a = d : a > e && (a = e), b.translate(a, 0, 1, 0, 1)
    }, autoLabelAlign: function (a) {
        var b, c = (eb(a, 0) - 90 * this.side + 720) % 360;
        return b = c > 15 && 165 > c ? "right" : c > 195 && 345 > c ? "left" : "center"
    }, unsquish: function () {
        var a, b, c, d = this.chart, e = this.ticks, f = this.options.labels, g = this.horiz, h = this.tickInterval, i = h, k = this.len / (((this.categories ? 1 : 0) + this.max - this.min) / h), l = f.rotation, m = d.renderer.fontMetrics(f.style.fontSize, e[0] && e[0].label), n = Number.MAX_VALUE, o = function (a) {
            var b = a / (k || 1);
            return b = b > 1 ? oa(b) : 1, b * h
        };
        return g ? (c = !f.staggerLines && !f.step && (j(l) ? [l] : k < eb(f.autoRotationLimit, 80) && f.autoRotation), c && lb(c, function (c) {
            var d;
            (c === l || c && c >= -90 && 90 >= c) && (b = o(ra(m.h / ta(va * c))), d = b + ra(c / 360), n > d && (n = d, a = c, i = b))
        })) : f.step || (i = o(m.h)), this.autoRotation = c, this.labelRotation = eb(a, l), i
    }, renderUnsquish: function () {
        var b, d, e, f, g = this.chart, h = g.renderer, i = this.tickPositions, j = this.ticks, k = this.options.labels, l = this.horiz, m = g.margin, n = this.categories ? i.length : i.length - 1, o = this.slotWidth = l && !k.step && !k.rotation && (this.staggerLines || 1) * g.plotWidth / n || !l && (m[3] && m[3] - g.spacing[3] || .33 * g.chartWidth), p = pa(1, ma(o - 2 * (k.padding || 5))), q = {}, r = h.fontMetrics(k.style.fontSize, j[0] && j[0].label), s = k.style.textOverflow, t = 0;
        if (c(k.rotation) || (q.rotation = k.rotation || 0), this.autoRotation)lb(i, function (a) {
            a = j[a], a && a.labelLength > t && (t = a.labelLength)
        }), t > p && t > r.h ? q.rotation = this.labelRotation : this.labelRotation = 0; else if (o && (b = {width: p + Ua}, !s))for (b.textOverflow = "clip", e = i.length; !l && e--;)f = i[e], d = j[f].label, d && ("ellipsis" === d.styles.textOverflow && d.css({textOverflow: "clip"}), d.getBBox().height > this.len / i.length - (r.h - r.f) && (d.specCss = {textOverflow: "ellipsis"}));
        q.rotation && (b = {width: (t > .5 * g.chartHeight ? .33 * g.chartHeight : g.chartHeight) + Ua}, s || (b.textOverflow = "ellipsis")), this.labelAlign = q.align = k.align || this.autoLabelAlign(this.labelRotation), lb(i, function (c) {
            var d = j[c], e = d && d.label;
            e && (e.attr(q), b && e.css(a(b, e.specCss)), delete e.specCss, d.rotation = q.rotation)
        }), this.tickRotCorr = h.rotCorr(r.b, this.labelRotation || 0, 2 === this.side)
    }, hasData: function () {
        return this.hasVisibleSeries || j(this.min) && j(this.max) && !!this.tickPositions
    }, getOffset: function () {
        var a, b, c, d, e, f, g, h = this, i = h.chart, k = i.renderer, l = h.options, m = h.tickPositions, n = h.ticks, o = h.horiz, p = h.side, q = i.inverted ? [1, 0, 3, 2][p] : p, r = 0, s = 0, t = l.title, u = l.labels, v = 0, w = i.axisOffset, x = i.clipOffset, y = [-1, 1, 1, -1][p], z = h.axisParent;
        if (a = h.hasData(), h.showAxis = b = a || eb(l.showEmpty, !0), h.staggerLines = h.horiz && u.staggerLines, h.axisGroup || (h.gridGroup = k.g("grid").attr({zIndex: l.gridZIndex || 1}).add(z), h.axisGroup = k.g("axis").attr({zIndex: l.zIndex || 2}).add(z), h.labelGroup = k.g("axis-labels").attr({zIndex: u.zIndex || 7}).addClass(Sa + h.coll.toLowerCase() + "-labels").add(z)), a || h.isLinked)lb(m, function (a) {
            n[a] ? n[a].addLabel() : n[a] = new I(h, a)
        }), h.renderUnsquish(), lb(m, function (a) {
            (0 === p || 2 === p || {1: "left", 3: "right"}[p] === h.labelAlign) && (v = pa(n[a].getLabelSize(), v))
        }), h.staggerLines && (v *= h.staggerLines, h.labelOffset = v); else for (f in n)n[f].destroy(), delete n[f];
        t && t.text && t.enabled !== !1 && (h.axisTitle || (h.axisTitle = k.text(t.text, 0, 0, t.useHTML).attr({zIndex: 7, rotation: t.rotation || 0, align: t.textAlign || {low: "left", middle: "center", high: "right"}[t.align]}).addClass(Sa + this.coll.toLowerCase() + "-title").css(t.style).add(h.axisGroup), h.axisTitle.isNew = !0), b && (r = h.axisTitle.getBBox()[o ? "height" : "width"], c = t.offset, s = j(c) ? 0 : eb(t.margin, o ? 5 : 10)), h.axisTitle[b ? "show" : "hide"]()), h.offset = y * eb(l.offset, w[p]), h.tickRotCorr = h.tickRotCorr || {x: 0, y: 0}, g = 2 === p ? h.tickRotCorr.y : 0, d = v + s + (v && y * (o ? eb(u.y, h.tickRotCorr.y + 8) : u.x) - g), h.axisTitleMargin = eb(c, d), w[p] = pa(w[p], h.axisTitleMargin + r + y * h.offset, d), e = l.offset ? 0 : 2 * na(l.lineWidth / 2), x[q] = pa(x[q], e)
    }, getLinePath: function (a) {
        var b = this.chart, c = this.opposite, d = this.offset, e = this.horiz, f = this.left + (c ? this.width : 0) + d, g = b.chartHeight - this.bottom - (c ? this.height : 0) + d;
        return c && (a *= -1), b.renderer.crispLine([Wa, e ? this.left : f, e ? g : this.top, Xa, e ? b.chartWidth - this.right : f, e ? g : b.chartHeight - this.bottom], a)
    }, getTitlePosition: function () {
        var a = this.horiz, c = this.left, d = this.top, e = this.len, f = this.options.title, g = a ? c : d, h = this.opposite, i = this.offset, j = f.x || 0, k = f.y || 0, l = b(f.style.fontSize || 12), m = {low: g + (a ? 0 : e), middle: g + e / 2, high: g + (a ? e : 0)}[f.align], n = (a ? d + this.height : c) + (a ? 1 : -1) * (h ? -1 : 1) * this.axisTitleMargin + (2 === this.side ? l : 0);
        return{x: a ? m + j : n + (h ? this.width : 0) + i + j, y: a ? n + k - (h ? this.height : 0) + i : m + k}
    }, render: function () {
        var a, b, c, d = this, e = d.chart, f = e.renderer, g = d.options, i = d.isLog, k = d.isLinked, l = d.tickPositions, m = d.axisTitle, n = d.ticks, o = d.minorTicks, p = d.alternateBands, q = g.stackLabels, r = g.alternateGridColor, s = d.tickmarkOffset, t = g.lineWidth, u = e.hasRendered, v = u && j(d.oldMin) && !isNaN(d.oldMin), w = d.showAxis, x = f.globalAnimation;
        d.labelEdge.length = 0, d.overlap = !1, lb([n, o, p], function (a) {
            var b;
            for (b in a)a[b].isActive = !1
        }), (d.hasData() || k) && (d.minorTickInterval && !d.categories && lb(d.getMinorTickPositions(), function (a) {
            o[a] || (o[a] = new I(d, a, "minor")), v && o[a].isNew && o[a].render(null, !0), o[a].render(null, !1, 1)
        }), l.length && (lb(l, function (a, b) {
            (!k || a >= d.min && a <= d.max) && (n[a] || (n[a] = new I(d, a)), v && n[a].isNew && n[a].render(b, !0, .1), n[a].render(b))
        }), s && (0 === d.min || d.single) && (n[-1] || (n[-1] = new I(d, -1, null, !0)), n[-1].render(-1))), r && lb(l, function (a, e) {
            c = l[e + 1] !== K ? l[e + 1] + s : d.max - s, e % 2 === 0 && a < d.max && c <= d.max - s && (p[a] || (p[a] = new ia.PlotLineOrBand(d)), b = a + s, p[a].options = {from: i ? h(b) : b, to: i ? h(c) : c, color: r}, p[a].render(), p[a].isActive = !0)
        }), d._addedPlotLB || (lb((g.plotLines || []).concat(g.plotBands || []), function (a) {
            d.addPlotBandOrLine(a)
        }), d._addedPlotLB = !0)), lb([n, o, p], function (a) {
            var b, c, d = [], f = x ? x.duration || 500 : 0, g = function () {
                for (c = d.length; c--;)a[d[c]] && !a[d[c]].isActive && (a[d[c]].destroy(), delete a[d[c]])
            };
            for (b in a)a[b].isActive || (a[b].render(b, !1, 0), a[b].isActive = !1, d.push(b));
            a !== p && e.hasRendered && f ? f && setTimeout(g, f) : g()
        }), t && (a = d.getLinePath(t), d.axisLine ? d.axisLine.animate({d: a}) : d.axisLine = f.path(a).attr({stroke: g.lineColor, "stroke-width": t, zIndex: 7}).add(d.axisGroup), d.axisLine[w ? "show" : "hide"]()), m && w && (m[m.isNew ? "attr" : "animate"](d.getTitlePosition()), m.isNew = !1), q && q.enabled && d.renderStackTotals(), d.isDirty = !1
    }, redraw: function () {
        this.visible && (this.render(), lb(this.plotLinesAndBands, function (a) {
            a.render()
        })), lb(this.series, function (a) {
            a.isDirty = !0
        })
    }, destroy: function (a) {
        var b, c, d = this, e = d.stacks, f = d.plotLinesAndBands;
        a || qb(d);
        for (b in e)z(e[b]), e[b] = null;
        for (lb([d.ticks, d.minorTicks, d.alternateBands], function (a) {
            z(a)
        }), c = f.length; c--;)f[c].destroy();
        lb(["stackTotalGroup", "axisLine", "axisTitle", "axisGroup", "cross", "gridGroup", "labelGroup"], function (a) {
            d[a] && (d[a] = d[a].destroy())
        }), this.cross && this.cross.destroy()
    }, drawCrosshair: function (a, b) {
        var c, d, e, f, g = this.crosshair, h = g.animation;
        if (!this.crosshair || (j(b) || !eb(this.crosshair.snap, !0)) === !1 || b && b.series && b.series[this.coll] !== this)this.hideCrosshair(); else {
            if (eb(g.snap, !0) ? j(b) && (d = this.isXAxis ? b.plotX : this.len - b.plotY) : d = this.horiz ? a.chartX - this.pos : this.len - a.chartY + this.pos, c = this.isRadial ? this.getPlotLinePath(this.isXAxis ? b.x : eb(b.stackY, b.y)) || null : this.getPlotLinePath(null, null, null, null, d) || null, null === c)return void this.hideCrosshair();
            this.cross ? this.cross.attr({visibility: Ta})[h ? "animate" : "attr"]({d: c}, h) : (f = this.categories && !this.isRadial, e = {"stroke-width": g.width || (f ? this.transA : 1), stroke: g.color || (f ? "rgba(155,200,255,0.2)" : "#C0C0C0"), zIndex: g.zIndex || 2}, g.dashStyle && (e.dashstyle = g.dashStyle), this.cross = this.chart.renderer.path(c).attr(e).add())
        }
    }, hideCrosshair: function () {
        this.cross && this.cross.hide()
    }}, db(Hb.prototype, S), Hb.prototype.getTimeTicks = function (a, b, c, d) {
        var e, f, g = [], h = {}, i = O.global.useUTC, k = new T(b - r(b)), l = a.unitRange, m = a.count;
        if (j(b)) {
            k[ba](l >= R.second ? 0 : m * na(k.getMilliseconds() / m)), l >= R.second && k[ca](l >= R.minute ? 0 : m * na(k.getSeconds() / m)), l >= R.minute && k[da](l >= R.hour ? 0 : m * na(k[X]() / m)), l >= R.hour && k[ea](l >= R.day ? 0 : m * na(k[Y]() / m)), l >= R.day && k[fa](l >= R.month ? 1 : m * na(k[$]() / m)), l >= R.month && (k[ga](l >= R.year ? 0 : m * na(k[_]() / m)), f = k[aa]()), l >= R.year && (f -= f % m, k[ha](f)), l === R.week && k[fa](k[$]() - k[Z]() + eb(d, 1)), e = 1, (V || W) && (k = k.getTime(), k = new T(k + r(k))), f = k[aa]();
            for (var n = k.getTime(), o = k[_](), p = k[$](), q = (R.day + (i ? r(k) : 60 * k.getTimezoneOffset() * 1e3)) % R.day; c > n;)g.push(n), l === R.year ? n = U(f + e * m, 0) : l === R.month ? n = U(f, o + e * m) : i || l !== R.day && l !== R.week ? n += l * m : n = U(f, o, p + e * m * (l === R.day ? 1 : 7)), e++;
            g.push(n), lb(mb(g, function (a) {
                return l <= R.hour && a % R.day === q
            }), function (a) {
                h[a] = "day"
            })
        }
        return g.info = db(a, {higherRanks: h, totalRange: l * m}), g
    }, Hb.prototype.normalizeTimeTickInterval = function (a, b) {
        var c, d, e = b || [
            ["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]],
            ["second", [1, 2, 5, 10, 15, 30]],
            ["minute", [1, 2, 5, 10, 15, 30]],
            ["hour", [1, 2, 3, 4, 6, 8, 12]],
            ["day", [1, 2]],
            ["week", [1, 2]],
            ["month", [1, 2, 3, 4, 6]],
            ["year", null]
        ], f = e[e.length - 1], g = R[f[0]], h = f[1];
        for (d = 0; d < e.length; d++)if (f = e[d], g = R[f[0]], h = f[1], e[d + 1]) {
            var i = (g * h[h.length - 1] + R[e[d + 1][0]]) / 2;
            if (i >= a)break
        }
        return g === R.year && 5 * g > a && (h = [1, 2, 5]), c = v(a / g, h, "year" === f[0] ? pa(u(a / g), 1) : 1), {unitRange: g, count: c, unitName: f[0]}
    }, Hb.prototype.getLogTickPositions = function (a, b, c, d) {
        var e = this, f = e.options, i = e.len, j = [];
        if (d || (e._minorAutoInterval = null), a >= .5)a = ma(a), j = e.getLinearTickPositions(a, b, c); else if (a >= .08) {
            var k, l, m, n, o, p, q, r = na(b);
            for (k = a > .3 ? [1, 2, 4] : a > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9], l = r; c + 1 > l && !q; l++)for (n = k.length, m = 0; n > m && !q; m++)o = g(h(l) * k[m]), o > b && (!d || c >= p) && p !== K && j.push(p), p > c && (q = !0), p = o
        } else {
            var s = h(b), t = h(c), w = f[d ? "minorTickInterval" : "tickInterval"], x = "auto" === w ? null : w, y = f.tickPixelInterval / (d ? 5 : 1), z = d ? i / e.tickPositions.length : i;
            a = eb(x, e._minorAutoInterval, (t - s) * y / (z || 1)), a = v(a, null, u(a)), j = ob(e.getLinearTickPositions(a, s, t), g), d || (e._minorAutoInterval = a / 5)
        }
        return d || (e.tickInterval = a), j
    };
    var Ib = ia.Tooltip = function () {
        this.init.apply(this, arguments)
    };
    Ib.prototype = {init: function (a, c) {
        var d = c.borderWidth, e = c.style, f = b(e.padding);
        this.chart = a, this.options = c, this.crosshairs = [], this.now = {x: 0, y: 0}, this.isHidden = !0, this.label = a.renderer.label("", 0, 0, c.shape || "callout", null, null, c.useHTML, null, "tooltip").attr({padding: f, fill: c.backgroundColor, "stroke-width": d, r: c.borderRadius, zIndex: 8}).css(e).css({padding: 0}).add().attr({y: -9999}), Ga || this.label.shadow(c.shadow), this.shared = c.shared
    }, destroy: function () {
        this.label && (this.label = this.label.destroy()), clearTimeout(this.hideTimer), clearTimeout(this.tooltipTimeout)
    }, move: function (a, b, c, d) {
        var e = this, f = e.now, g = e.options.animation !== !1 && !e.isHidden && (ra(a - f.x) > 1 || ra(b - f.y) > 1), h = e.followPointer || e.len > 1;
        db(f, {x: g ? (2 * f.x + a) / 3 : a, y: g ? (f.y + b) / 2 : b, anchorX: h ? K : g ? (2 * f.anchorX + c) / 3 : c, anchorY: h ? K : g ? (f.anchorY + d) / 2 : d}), e.label.attr(f), g && (clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () {
            e && e.move(a, b, c, d)
        }, 32))
    }, hide: function (a) {
        var b, c = this;
        clearTimeout(this.hideTimer), this.isHidden || (b = this.chart.hoverPoints, this.hideTimer = setTimeout(function () {
            c.label.fadeOut(), c.isHidden = !0
        }, eb(a, this.options.hideDelay, 500)))
    }, getAnchor: function (a, b) {
        var c, d, e, f = this.chart, g = f.inverted, h = f.plotTop, i = f.plotLeft, j = 0, k = 0;
        return a = l(a), c = a[0].tooltipPos, this.followPointer && b && (b.chartX === K && (b = f.pointer.normalize(b)), c = [b.chartX - f.plotLeft, b.chartY - h]), c || (lb(a, function (a) {
            d = a.series.yAxis, e = a.series.xAxis, j += a.plotX + (!g && e ? e.left - i : 0), k += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!g && d ? d.top - h : 0)
        }), j /= a.length, k /= a.length, c = [g ? f.plotWidth - k : j, this.shared && !g && a.length > 1 && b ? b.chartY - h : g ? f.plotHeight - j : k]), ob(c, ma)
    }, getPosition: function (a, b, c) {
        var d, e = this.chart, f = this.distance, g = {}, h = c.h || 0, i = ["y", e.chartHeight, b, c.plotY + e.plotTop, e.plotTop, e.plotTop + e.plotHeight], j = ["x", e.chartWidth, a, c.plotX + e.plotLeft, e.plotLeft, e.plotLeft + e.plotWidth], k = eb(c.ttBelow, e.inverted && !c.negative || !e.inverted && c.negative), l = function (a, b, c, d, e, i) {
            var j = d - f > c, l = b > d + f + c, m = d - f - c, n = d + f;
            if (k && l)g[a] = n; else if (!k && j)g[a] = m; else if (j)g[a] = qa(i - c, 0 > m - h ? m : m - h); else {
                if (!l)return!1;
                g[a] = pa(e, n + h + c > b ? n : n + h)
            }
        }, m = function (a, b, c, d) {
            return f > d || d > b - f ? !1 : void(c / 2 > d ? g[a] = 1 : d > b - c / 2 ? g[a] = b - c - 2 : g[a] = d - c / 2)
        }, n = function (a) {
            var b = i;
            i = j, j = b, d = a
        }, o = function () {
            l.apply(0, i) !== !1 ? m.apply(0, j) !== !1 || d || (n(!0), o()) : d ? g.x = g.y = 0 : (n(!0), o())
        };
        return(e.inverted || this.len > 1) && n(), o(), g
    }, defaultFormatter: function (a) {
        var b, c = this.points || l(this);
        return b = [a.tooltipFooterHeaderFormatter(c[0])], b = b.concat(a.bodyFormatter(c)), b.push(a.tooltipFooterHeaderFormatter(c[0], !0)), b.join("")
    }, refresh: function (a, b) {
        var c, d, e, f, g, h, i = this, j = i.chart, k = i.label, m = i.options, n = {}, o = [], p = m.formatter || i.defaultFormatter, q = j.hoverPoints, r = i.shared;
        clearTimeout(this.hideTimer), i.followPointer = l(a)[0].series.tooltipOptions.followPointer, e = i.getAnchor(a, b), c = e[0], d = e[1], !r || a.series && a.series.noSharedTooltip ? n = a.getLabelConfig() : (j.hoverPoints = a, q && lb(q, function (a) {
            a.setState()
        }), lb(a, function (a) {
            a.setState($a), o.push(a.getLabelConfig())
        }), n = {x: a[0].category, y: a[0].y}, n.points = o, this.len = o.length, a = a[0]), f = p.call(n, i), h = a.series, this.distance = eb(h.tooltipOptions.distance, 16), f === !1 ? this.hide() : (i.isHidden && (ub(k), k.attr("opacity", 1).show()), k.attr({text: f}), g = m.borderColor || a.color || h.color || "#606060", k.attr({stroke: g}), i.updatePosition({plotX: c, plotY: d, negative: a.negative, ttBelow: a.ttBelow, h: e[2] || 0}), this.isHidden = !1), rb(j, "tooltipRefresh", {text: f, x: c + j.plotLeft, y: d + j.plotTop, borderColor: g})
    }, updatePosition: function (a) {
        var b = this.chart, c = this.label, d = (this.options.positioner || this.getPosition).call(this, c.width, c.height, a);
        this.move(ma(d.x), ma(d.y || 0), a.plotX + b.plotLeft, a.plotY + b.plotTop)
    }, getXDateFormat: function (a, b, c) {
        var d, e, f, g = b.dateTimeLabelFormats, h = c && c.closestPointRange, i = "01-01 00:00:00.000", j = {millisecond: 15, second: 12, minute: 9, hour: 6, day: 3}, k = "millisecond";
        if (h) {
            f = P("%m-%d %H:%M:%S.%L", a.x);
            for (e in R) {
                if (h === R.week && +P("%w", a.x) === c.options.startOfWeek && f.substr(6) === i.substr(6)) {
                    e = "week";
                    break
                }
                if (R[e] > h) {
                    e = k;
                    break
                }
                if (j[e] && f.substr(j[e]) !== i.substr(j[e]))break;
                "week" !== e && (k = e)
            }
            e && (d = g[e])
        } else d = g.day;
        return d || g.year
    }, tooltipFooterHeaderFormatter: function (a, b) {
        var c = b ? "footer" : "header", d = a.series, e = d.tooltipOptions, g = e.xDateFormat, h = d.xAxis, i = h && "datetime" === h.options.type && f(a.key), j = e[c + "Format"];
        return i && !g && (g = this.getXDateFormat(a, e, h)), i && g && (j = j.replace("{point.key}", "{point.key:" + g + "}")), t(j, {point: a, series: d})
    }, bodyFormatter: function (a) {
        return ob(a, function (a) {
            var b = a.series.tooltipOptions;
            return(b.pointFormatter || a.point.tooltipFormatter).call(a.point, b.pointFormat)
        })
    }};
    var Jb;
    M = ja.documentElement.ontouchstart !== K;
    var Kb = ia.Pointer = function (a, b) {
        this.init(a, b)
    };
    if (Kb.prototype = {init: function (a, b) {
        var c, d, e = b.chart, f = e.events, g = Ga ? "" : e.zoomType, h = a.inverted;
        this.options = b, this.chart = a, this.zoomX = c = /x/.test(g), this.zoomY = d = /y/.test(g), this.zoomHor = c && !h || d && h, this.zoomVert = d && !h || c && h, this.hasZoom = c || d, this.runChartClick = f && !!f.click, this.pinchDown = [], this.lastValidTouch = {}, ia.Tooltip && b.tooltip.enabled && (a.tooltip = new Ib(a, b.tooltip), this.followTouchMove = eb(b.tooltip.followTouchMove, !0)), this.setDOMEvents()
    }, normalize: function (a, b) {
        var c, d, e;
        return a = a || window.event, a = sb(a), a.target || (a.target = a.srcElement), e = a.touches ? a.touches.length ? a.touches.item(0) : a.changedTouches[0] : a, b || (this.chartPosition = b = nb(this.chart.container)), e.pageX === K ? (c = pa(a.x, a.clientX - b.left), d = a.y) : (c = e.pageX - b.left, d = e.pageY - b.top), db(a, {chartX: ma(c), chartY: ma(d)})
    }, getCoordinates: function (a) {
        var b = {xAxis: [], yAxis: []};
        return lb(this.chart.axes, function (c) {
            b[c.isXAxis ? "xAxis" : "yAxis"].push({axis: c, value: c.toValue(a[c.horiz ? "chartX" : "chartY"])})
        }), b
    }, runPointActions: function (a) {
        var b, c, d, e, f, g, h, i, j = this, k = j.chart, l = k.series, m = k.tooltip, n = m ? m.shared : !1, o = k.hoverPoint, p = k.hoverSeries, q = Number.MAX_VALUE, r = [];
        if (!n && !p)for (c = 0; c < l.length; c++)(l[c].directTouch || !l[c].options.stickyTracking) && (l = []);
        if (f = p && (n ? p.noSharedTooltip : p.directTouch), f && o ? h = o : (lb(l, function (b) {
            e = b.noSharedTooltip && n, g = !n && b.directTouch, b.visible && !e && !g && eb(b.options.enableMouseTracking, !0) && (i = b.searchPoint(a, !e && 1 === b.kdDimensions), i && r.push(i))
        }), lb(r, function (a) {
            a && "number" == typeof a.dist && a.dist < q && (q = a.dist, h = a)
        })), h && (h !== this.prevKDPoint || m && m.isHidden)) {
            if (n && !h.series.noSharedTooltip) {
                for (c = r.length; c--;)(r[c].clientX !== h.clientX || r[c].series.noSharedTooltip) && r.splice(c, 1);
                r.length && m && m.refresh(r, a), lb(r, function (b) {
                    b.onMouseOver(a, b !== (p && p.directTouch && o || h))
                })
            } else m && m.refresh(h, a), p && p.directTouch || h.onMouseOver(a);
            this.prevKDPoint = h
        } else b = p && p.tooltipOptions.followPointer, m && b && !m.isHidden && (d = m.getAnchor([
            {}
        ], a), m.updatePosition({plotX: d[0], plotY: d[1]}));
        m && !j._onDocumentMouseMove && (j._onDocumentMouseMove = function (a) {
            Ka[Jb] && Ka[Jb].pointer.onDocumentMouseMove(a)
        }, pb(ja, "mousemove", j._onDocumentMouseMove)), lb(k.axes, function (b) {
            b.drawCrosshair(a, eb(h, o))
        })
    }, reset: function (a, b) {
        var c = this, d = c.chart, e = d.hoverSeries, f = d.hoverPoint, g = d.hoverPoints, h = d.tooltip, i = h && h.shared ? g : f;
        a = a && h && i, a && l(i)[0].plotX === K && (a = !1), a ? (h.refresh(i), f && (f.setState(f.state, !0), lb(d.axes, function (a) {
            eb(a.options.crosshair && a.options.crosshair.snap, !0) ? a.drawCrosshair(null, f) : a.hideCrosshair()
        }))) : (f && f.onMouseOut(), g && lb(g, function (a) {
            a.setState()
        }), e && e.onMouseOut(), h && h.hide(b), c._onDocumentMouseMove && (qb(ja, "mousemove", c._onDocumentMouseMove), c._onDocumentMouseMove = null), lb(d.axes, function (a) {
            a.hideCrosshair()
        }), c.hoverX = d.hoverPoints = d.hoverPoint = null)
    }, scaleGroups: function (a, b) {
        var c, d = this.chart;
        lb(d.series, function (e) {
            c = a || e.getPlotBox(), e.xAxis && e.xAxis.zoomEnabled && (e.group.attr(c), e.markerGroup && (e.markerGroup.attr(c), e.markerGroup.clip(b ? d.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(c))
        }), d.clipRect.attr(b || d.clipBox)
    }, dragStart: function (a) {
        var b = this.chart;
        b.mouseIsDown = a.type, b.cancelClick = !1, b.mouseDownX = this.mouseDownX = a.chartX, b.mouseDownY = this.mouseDownY = a.chartY
    }, drag: function (a) {
        var b, c, d = this.chart, e = d.options.chart, f = a.chartX, g = a.chartY, h = this.zoomHor, i = this.zoomVert, j = d.plotLeft, k = d.plotTop, l = d.plotWidth, m = d.plotHeight, n = this.selectionMarker, o = this.mouseDownX, p = this.mouseDownY, q = e.panKey && a[e.panKey + "Key"];
        n && n.touch || (j > f ? f = j : f > j + l && (f = j + l), k > g ? g = k : g > k + m && (g = k + m), this.hasDragged = Math.sqrt(Math.pow(o - f, 2) + Math.pow(p - g, 2)), this.hasDragged > 10 && (b = d.isInsidePlot(o - j, p - k), d.hasCartesianSeries && (this.zoomX || this.zoomY) && b && !q && (n || (this.selectionMarker = n = d.renderer.rect(j, k, h ? 1 : l, i ? 1 : m, 0).attr({fill: e.selectionMarkerFill || "rgba(69,114,167,0.25)", zIndex: 7}).add())), n && h && (c = f - o, n.attr({width: ra(c), x: (c > 0 ? 0 : c) + o})), n && i && (c = g - p, n.attr({height: ra(c), y: (c > 0 ? 0 : c) + p})), b && !n && e.panning && d.pan(a, e.panning)))
    }, drop: function (a) {
        var b = this, c = this.chart, d = this.hasPinched;
        if (this.selectionMarker) {
            var e, f = {xAxis: [], yAxis: [], originalEvent: a.originalEvent || a}, g = this.selectionMarker, h = g.attr ? g.attr("x") : g.x, i = g.attr ? g.attr("y") : g.y, k = g.attr ? g.attr("width") : g.width, l = g.attr ? g.attr("height") : g.height;
            (this.hasDragged || d) && (lb(c.axes, function (c) {
                if (c.zoomEnabled && j(c.min) && (d || b[{xAxis: "zoomX", yAxis: "zoomY"}[c.coll]])) {
                    var g = c.horiz, m = "touchend" === a.type ? c.minPixelPadding : 0, n = c.toValue((g ? h : i) + m), o = c.toValue((g ? h + k : i + l) - m);
                    f[c.coll].push({axis: c, min: qa(n, o), max: pa(n, o)}), e = !0
                }
            }), e && rb(c, "selection", f, function (a) {
                c.zoom(db(a, d ? {animation: !1} : null))
            })), this.selectionMarker = this.selectionMarker.destroy(), d && this.scaleGroups()
        }
        c && (m(c.container, {cursor: c._cursor}), c.cancelClick = this.hasDragged > 10, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = [])
    }, onContainerMouseDown: function (a) {
        a = this.normalize(a), a.preventDefault && a.preventDefault(), this.dragStart(a)
    }, onDocumentMouseUp: function (a) {
        Ka[Jb] && Ka[Jb].pointer.drop(a)
    }, onDocumentMouseMove: function (a) {
        var b = this.chart, c = this.chartPosition;
        a = this.normalize(a, c), !c || this.inClass(a.target, "highcharts-tracker") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || this.reset()
    }, onContainerMouseLeave: function () {
        var a = Ka[Jb];
        a && (a.pointer.reset(), a.pointer.chartPosition = null)
    }, onContainerMouseMove: function (a) {
        var b = this.chart;
        Jb = b.index, a = this.normalize(a), a.returnValue = !1, "mousedown" === b.mouseIsDown && this.drag(a), !this.inClass(a.target, "highcharts-tracker") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || b.openMenu || this.runPointActions(a)
    }, inClass: function (a, b) {
        for (var c; a;) {
            if (c = k(a, "class")) {
                if (-1 !== c.indexOf(b))return!0;
                if (-1 !== c.indexOf(Sa + "container"))return!1
            }
            a = a.parentNode
        }
    }, onTrackerMouseOut: function (a) {
        var b = this.chart.hoverSeries, c = a.relatedTarget || a.toElement;
        !b || b.options.stickyTracking || this.inClass(c, Sa + "tooltip") || this.inClass(c, Sa + "series-" + b.index) || b.onMouseOut()
    }, onContainerClick: function (a) {
        var b = this.chart, c = b.hoverPoint, d = b.plotLeft, e = b.plotTop;
        a = this.normalize(a), a.originalEvent = a, b.cancelClick || (c && this.inClass(a.target, Sa + "tracker") ? (rb(c.series, "click", db(a, {point: c})), b.hoverPoint && c.firePointEvent("click", a)) : (db(a, this.getCoordinates(a)), b.isInsidePlot(a.chartX - d, a.chartY - e) && rb(b, "click", a)))
    }, setDOMEvents: function () {
        var a = this, b = a.chart.container;
        b.onmousedown = function (b) {
            a.onContainerMouseDown(b)
        }, b.onmousemove = function (b) {
            a.onContainerMouseMove(b)
        }, b.onclick = function (b) {
            a.onContainerClick(b)
        }, pb(b, "mouseleave", a.onContainerMouseLeave), 1 === La && pb(ja, "mouseup", a.onDocumentMouseUp), M && (b.ontouchstart = function (b) {
            a.onContainerTouchStart(b)
        }, b.ontouchmove = function (b) {
            a.onContainerTouchMove(b)
        }, 1 === La && pb(ja, "touchend", a.onDocumentTouchEnd))
    }, destroy: function () {
        var a;
        qb(this.chart.container, "mouseleave", this.onContainerMouseLeave), La || (qb(ja, "mouseup", this.onDocumentMouseUp), qb(ja, "touchend", this.onDocumentTouchEnd)), clearInterval(this.tooltipTimeout);
        for (a in this)this[a] = null
    }}, db(ia.Pointer.prototype, {pinchTranslate: function (a, b, c, d, e, f) {
        (this.zoomHor || this.pinchHor) && this.pinchTranslateDirection(!0, a, b, c, d, e, f), (this.zoomVert || this.pinchVert) && this.pinchTranslateDirection(!1, a, b, c, d, e, f)
    }, pinchTranslateDirection: function (a, b, c, d, e, f, g, h) {
        var i, j, k, l, m, n, o = this.chart, p = a ? "x" : "y", q = a ? "X" : "Y", r = "chart" + q, s = a ? "width" : "height", t = o["plot" + (a ? "Left" : "Top")], u = h || 1, v = o.inverted, w = o.bounds[a ? "h" : "v"], x = 1 === b.length, y = b[0][r], z = c[0][r], A = !x && b[1][r], B = !x && c[1][r], C = function () {
            !x && ra(y - A) > 20 && (u = h || ra(z - B) / ra(y - A)), k = (t - z) / u + y, i = o["plot" + (a ? "Width" : "Height")] / u
        };
        C(), j = k, j < w.min ? (j = w.min, l = !0) : j + i > w.max && (j = w.max - i, l = !0), l ? (z -= .8 * (z - g[p][0]), x || (B -= .8 * (B - g[p][1])), C()) : g[p] = [z, B], v || (f[p] = k - t, f[s] = i), n = v ? a ? "scaleY" : "scaleX" : "scale" + q, m = v ? 1 / u : u, e[s] = i, e[p] = j, d[n] = u, d["translate" + q] = m * t + (z - m * y)
    }, pinch: function (a) {
        var b = this, c = b.chart, d = b.pinchDown, e = a.touches, f = e.length, g = b.lastValidTouch, h = b.hasZoom, i = b.selectionMarker, j = {}, k = 1 === f && (b.inClass(a.target, Sa + "tracker") && c.runTrackerClick || b.runChartClick), l = {};
        f > 1 && (b.initiated = !0), h && b.initiated && !k && a.preventDefault(), ob(e, function (a) {
            return b.normalize(a)
        }), "touchstart" === a.type ? (lb(e, function (a, b) {
            d[b] = {chartX: a.chartX, chartY: a.chartY}
        }), g.x = [d[0].chartX, d[1] && d[1].chartX], g.y = [d[0].chartY, d[1] && d[1].chartY], lb(c.axes, function (a) {
            if (a.zoomEnabled) {
                var b = c.bounds[a.horiz ? "h" : "v"], d = a.minPixelPadding, e = a.toPixels(eb(a.options.min, a.dataMin)), f = a.toPixels(eb(a.options.max, a.dataMax)), g = qa(e, f), h = pa(e, f);
                b.min = qa(a.pos, g - d), b.max = pa(a.pos + a.len, h + d)
            }
        }), b.res = !0) : d.length && (i || (b.selectionMarker = i = db({destroy: Ja, touch: !0}, c.plotBox)), b.pinchTranslate(d, e, j, i, l, g), b.hasPinched = h, b.scaleGroups(j, l), !h && b.followTouchMove && 1 === f ? this.runPointActions(b.normalize(a)) : b.res && (b.res = !1, this.reset(!1, 0)))
    }, touch: function (a, b) {
        var c = this.chart;
        Jb = c.index, 1 === a.touches.length ? (a = this.normalize(a), c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop) && !c.openMenu ? (b && this.runPointActions(a), this.pinch(a)) : b && this.reset()) : 2 === a.touches.length && this.pinch(a)
    }, onContainerTouchStart: function (a) {
        this.touch(a, !0)
    }, onContainerTouchMove: function (a) {
        this.touch(a)
    }, onDocumentTouchEnd: function (a) {
        Ka[Jb] && Ka[Jb].pointer.drop(a)
    }}), ka.PointerEvent || ka.MSPointerEvent) {
        var Lb = {}, Mb = !!ka.PointerEvent, Nb = function () {
            var a, b = [];
            b.item = function (a) {
                return this[a]
            };
            for (a in Lb)Lb.hasOwnProperty(a) && b.push({pageX: Lb[a].pageX, pageY: Lb[a].pageY, target: Lb[a].target});
            return b
        }, Ob = function (a, b, c, d) {
            var e;
            a = a.originalEvent || a, "touch" !== a.pointerType && a.pointerType !== a.MSPOINTER_TYPE_TOUCH || !Ka[Jb] || (d(a), e = Ka[Jb].pointer, e[b]({type: c, target: a.currentTarget, preventDefault: Ja, touches: Nb()}))
        };
        db(Kb.prototype, {onContainerPointerDown: function (a) {
            Ob(a, "onContainerTouchStart", "touchstart", function (a) {
                Lb[a.pointerId] = {pageX: a.pageX, pageY: a.pageY, target: a.currentTarget}
            })
        }, onContainerPointerMove: function (a) {
            Ob(a, "onContainerTouchMove", "touchmove", function (a) {
                Lb[a.pointerId] = {pageX: a.pageX, pageY: a.pageY}, Lb[a.pointerId].target || (Lb[a.pointerId].target = a.currentTarget)
            })
        }, onDocumentPointerUp: function (a) {
            Ob(a, "onDocumentTouchEnd", "touchend", function (a) {
                delete Lb[a.pointerId]
            })
        }, batchMSEvents: function (a) {
            a(this.chart.container, Mb ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown), a(this.chart.container, Mb ? "pointermove" : "MSPointerMove", this.onContainerPointerMove), a(ja, Mb ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp)
        }}), fb(Kb.prototype, "init", function (a, b, c) {
            a.call(this, b, c), this.hasZoom && m(b.container, {"-ms-touch-action": Va, "touch-action": Va})
        }), fb(Kb.prototype, "setDOMEvents", function (a) {
            a.apply(this), (this.hasZoom || this.followTouchMove) && this.batchMSEvents(pb)
        }), fb(Kb.prototype, "destroy", function (a) {
            this.batchMSEvents(qb), a.call(this)
        })
    }
    var Pb = ia.Legend = function (a, b) {
        this.init(a, b)
    };
    Pb.prototype = {init: function (b, c) {
        var d, e = this, f = c.itemStyle, g = c.itemMarginTop || 0;
        this.options = c, c.enabled && (e.itemStyle = f, e.itemHiddenStyle = a(f, c.itemHiddenStyle), e.itemMarginTop = g, e.padding = d = eb(c.padding, 8), e.initialItemX = d, e.initialItemY = d - 5, e.maxItemWidth = 0, e.chart = b, e.itemHeight = 0, e.symbolWidth = eb(c.symbolWidth, 16), e.pages = [], e.render(), pb(e.chart, "endResize", function () {
            e.positionCheckboxes()
        }))
    }, colorizeItem: function (a, b) {
        var c, d, e = this, f = e.options, g = a.legendItem, h = a.legendLine, i = a.legendSymbol, j = e.itemHiddenStyle.color, k = b ? f.itemStyle.color : j, l = b ? a.legendColor || a.color || "#CCC" : j, m = a.options && a.options.marker, n = {fill: l};
        if (g && g.css({fill: k, color: k}), h && h.attr({stroke: l}), i) {
            if (m && i.isMarker) {
                n.stroke = l, m = a.convertAttribs(m);
                for (c in m)d = m[c], d !== K && (n[c] = d)
            }
            i.attr(n)
        }
    }, positionItem: function (a) {
        var b = this, c = b.options, d = c.symbolPadding, e = !c.rtl, f = a._legendItemPos, g = f[0], h = f[1], i = a.checkbox, j = a.legendGroup;
        j && j.element && j.translate(e ? g : b.legendWidth - g - 2 * d - 4, h), i && (i.x = g, i.y = h)
    }, destroyItem: function (a) {
        var b = a.checkbox;
        lb(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function (b) {
            a[b] && (a[b] = a[b].destroy())
        }), b && A(a.checkbox)
    }, destroy: function () {
        var a = this, b = a.group, c = a.box;
        c && (a.box = c.destroy()), b && (a.group = b.destroy())
    }, positionCheckboxes: function (a) {
        var b, c = this.group.alignAttr, d = this.clipHeight || this.legendHeight;
        c && (b = c.translateY, lb(this.allItems, function (e) {
            var f, g = e.checkbox;
            g && (f = b + g.y + (a || 0) + 3, m(g, {left: c.translateX + e.checkboxOffset + g.x - 20 + Ua, top: f + Ua, display: f > b - 6 && b + d - 6 > f ? "" : Va}))
        }))
    }, renderTitle: function () {
        var a, b = this.options, c = this.padding, d = b.title, e = 0;
        d.text && (this.title || (this.title = this.chart.renderer.label(d.text, c - 3, c - 4, null, null, null, null, null, "legend-title").attr({zIndex: 1}).css(d.style).add(this.group)), a = this.title.getBBox(), e = a.height, this.offsetWidth = a.width, this.contentGroup.attr({translateY: e})), this.titleHeight = e
    }, setText: function (a) {
        var b = this.options;
        a.legendItem.attr({text: b.labelFormat ? t(b.labelFormat, a) : b.labelFormatter.call(a)})
    }, renderItem: function (b) {
        var c, d, e, f = this, g = f.chart, h = g.renderer, i = f.options, j = "horizontal" === i.layout, k = f.symbolWidth, l = i.symbolPadding, m = f.itemStyle, n = f.itemHiddenStyle, o = f.padding, p = j ? eb(i.itemDistance, 20) : 0, q = !i.rtl, r = i.width, s = i.itemMarginBottom || 0, t = f.itemMarginTop, u = f.initialItemX, v = b.legendItem, w = b.series && b.series.drawLegendSymbol ? b.series : b, x = w.options, y = f.createCheckboxForItem && x && x.showCheckbox, z = i.useHTML;
        v || (b.legendGroup = h.g("legend-item").attr({zIndex: 1}).add(f.scrollGroup), b.legendItem = v = h.text("", q ? k + l : -l, f.baseline || 0, z).css(a(b.visible ? m : n)).attr({align: q ? "left" : "right", zIndex: 2}).add(b.legendGroup), f.baseline || (f.fontMetrics = h.fontMetrics(m.fontSize, v), f.baseline = f.fontMetrics.f + 3 + t, v.attr("y", f.baseline)), w.drawLegendSymbol(f, b), f.setItemEvents && f.setItemEvents(b, v, z, m, n), f.colorizeItem(b, b.visible), y && f.createCheckboxForItem(b)), f.setText(b), d = v.getBBox(), e = b.checkboxOffset = i.itemWidth || b.legendItemWidth || k + l + d.width + p + (y ? 20 : 0), f.itemHeight = c = ma(b.legendItemHeight || d.height), j && f.itemX - u + e > (r || g.chartWidth - 2 * o - u - i.x) && (f.itemX = u, f.itemY += t + f.lastLineHeight + s, f.lastLineHeight = 0), f.maxItemWidth = pa(f.maxItemWidth, e), f.lastItemY = t + f.itemY + s, f.lastLineHeight = pa(c, f.lastLineHeight), b._legendItemPos = [f.itemX, f.itemY], j ? f.itemX += e : (f.itemY += t + c + s, f.lastLineHeight = c), f.offsetWidth = r || pa((j ? f.itemX - u - p : e) + o, f.offsetWidth)
    }, getAllItems: function () {
        var a = [];
        return lb(this.chart.series, function (b) {
            var c = b.options;
            eb(c.showInLegend, j(c.linkedTo) ? !1 : K, !0) && (a = a.concat(b.legendItems || ("point" === c.legendType ? b.data : b)))
        }), a
    }, adjustMargins: function (a, b) {
        var c = this.chart, d = this.options, e = d.align.charAt(0) + d.verticalAlign.charAt(0) + d.layout.charAt(0);
        this.display && !d.floating && lb([/(lth|ct|rth)/, /(rtv|rm|rbv)/, /(rbh|cb|lbh)/, /(lbv|lm|ltv)/], function (f, g) {
            f.test(e) && !j(a[g]) && (c[ab[g]] = pa(c[ab[g]], c.legend[(g + 1) % 2 ? "legendHeight" : "legendWidth"] + [1, -1, -1, 1][g] * d[g % 2 ? "x" : "y"] + eb(d.margin, 12) + b[g]))
        })
    }, render: function () {
        var a, b, c, d, e = this, f = e.chart, g = f.renderer, h = e.group, i = e.box, j = e.options, k = e.padding, l = j.borderWidth, m = j.backgroundColor;
        e.itemX = e.initialItemX, e.itemY = e.initialItemY, e.offsetWidth = 0, e.lastItemY = 0, h || (e.group = h = g.g("legend").attr({zIndex: 7}).add(), e.contentGroup = g.g().attr({zIndex: 1}).add(h), e.scrollGroup = g.g().add(e.contentGroup)), e.renderTitle(), a = e.getAllItems(), w(a, function (a, b) {
            return(a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0)
        }), j.reversed && a.reverse(), e.allItems = a, e.display = b = !!a.length, e.lastLineHeight = 0, lb(a, function (a) {
            e.renderItem(a)
        }), c = (j.width || e.offsetWidth) + k, d = e.lastItemY + e.lastLineHeight + e.titleHeight, d = e.handleOverflow(d), d += k, (l || m) && (i ? c > 0 && d > 0 && (i[i.isNew ? "attr" : "animate"](i.crisp({width: c, height: d})), i.isNew = !1) : (e.box = i = g.rect(0, 0, c, d, j.borderRadius, l || 0).attr({stroke: j.borderColor, "stroke-width": l || 0, fill: m || Va}).add(h).shadow(j.shadow), i.isNew = !0), i[b ? "show" : "hide"]()), e.legendWidth = c, e.legendHeight = d, lb(a, function (a) {
            e.positionItem(a)
        }), b && h.align(db({width: c, height: d
        }, j), !0, "spacingBox"), f.isResizing || this.positionCheckboxes()
    }, handleOverflow: function (a) {
        var b, c, d = this, e = this.chart, f = e.renderer, g = this.options, h = g.y, i = "top" === g.verticalAlign, j = e.spacingBox.height + (i ? -h : h) - this.padding, k = g.maxHeight, l = this.clipRect, m = g.navigation, n = eb(m.animation, !0), o = m.arrowSize || 12, p = this.nav, q = this.pages, r = this.padding, s = this.allItems, t = function (a) {
            l.attr({height: a}), d.contentGroup.div && (d.contentGroup.div.style.clip = "rect(" + r + "px,9999px," + (r + a) + "px,0)")
        };
        return"horizontal" === g.layout && (j /= 2), k && (j = qa(j, k)), q.length = 0, a > j ? (this.clipHeight = b = pa(j - 20 - this.titleHeight - r, 0), this.currentPage = eb(this.currentPage, 1), this.fullHeight = a, lb(s, function (a, d) {
            var e = a._legendItemPos[1], f = ma(a.legendItem.getBBox().height), g = q.length;
            (!g || e - q[g - 1] > b && (c || e) !== q[g - 1]) && (q.push(c || e), g++), d === s.length - 1 && e + f - q[g - 1] > b && q.push(e), e !== c && (c = e)
        }), l || (l = d.clipRect = f.clipRect(0, r, 9999, 0), d.contentGroup.clip(l)), t(b), p || (this.nav = p = f.g().attr({zIndex: 1}).add(this.group), this.up = f.symbol("triangle", 0, 0, o, o).on("click", function () {
            d.scroll(-1, n)
        }).add(p), this.pager = f.text("", 15, 10).css(m.style).add(p), this.down = f.symbol("triangle-down", 0, 0, o, o).on("click", function () {
            d.scroll(1, n)
        }).add(p)), d.scroll(0), a = j) : p && (t(e.chartHeight), p.hide(), this.scrollGroup.attr({translateY: 1}), this.clipHeight = 0), a
    }, scroll: function (a, b) {
        var c, d = this.pages, e = d.length, f = this.currentPage + a, g = this.clipHeight, h = this.options.navigation, i = h.activeColor, j = h.inactiveColor, k = this.pager, l = this.padding;
        f > e && (f = e), f > 0 && (b !== K && D(b, this.chart), this.nav.attr({translateX: l, translateY: g + this.padding + 7 + this.titleHeight, visibility: Ta}), this.up.attr({fill: 1 === f ? j : i}).css({cursor: 1 === f ? "default" : "pointer"}), k.attr({text: f + "/" + e}), this.down.attr({x: 18 + this.pager.getBBox().width, fill: f === e ? j : i}).css({cursor: f === e ? "default" : "pointer"}), c = -d[f - 1] + this.initialItemY, this.scrollGroup.animate({translateY: c}), this.currentPage = f, this.positionCheckboxes(c))
    }};
    var Qb = ia.LegendSymbolMixin = {drawRectangle: function (a, b) {
        var c = a.options.symbolHeight || a.fontMetrics.f;
        b.legendSymbol = this.chart.renderer.rect(0, a.baseline - c + 1, a.symbolWidth, c, a.options.symbolRadius || 0).attr({zIndex: 3}).add(b.legendGroup)
    }, drawLineMarker: function (a) {
        var b, c, d, e = this.options, f = e.marker, g = a.symbolWidth, h = this.chart.renderer, i = this.legendGroup, j = a.baseline - ma(.3 * a.fontMetrics.b);
        e.lineWidth && (d = {"stroke-width": e.lineWidth}, e.dashStyle && (d.dashstyle = e.dashStyle), this.legendLine = h.path([Wa, 0, j, Xa, g, j]).attr(d).add(i)), f && f.enabled !== !1 && (b = f.radius, this.legendSymbol = c = h.symbol(this.symbol, g / 2 - b, j - b, 2 * b, 2 * b).add(i), c.isMarker = !0)
    }};
    (/Trident\/7\.0/.test(wa) || Ba) && fb(Pb.prototype, "positionItem", function (a, b) {
        var c = this, d = function () {
            b._legendItemPos && a.call(c, b)
        };
        d(), setTimeout(d)
    });
    var Rb = ia.Chart = function () {
        this.init.apply(this, arguments)
    };
    Rb.prototype = {callbacks: [], init: function (b, c) {
        var d, e = b.series;
        b.series = null, d = a(O, b), d.series = b.series = e, this.userOptions = b;
        var f = d.chart;
        this.margin = this.splashArray("margin", f), this.spacing = this.splashArray("spacing", f);
        var g = f.events;
        this.bounds = {h: {}, v: {}}, this.callback = c, this.isResizing = 0, this.options = d, this.axes = [], this.series = [], this.hasCartesianSeries = f.showAxes;
        var h, i = this;
        if (i.index = Ka.length, Ka.push(i), La++, f.reflow !== !1 && pb(i, "load", function () {
            i.initReflow()
        }), g)for (h in g)pb(i, h, g[h]);
        i.xAxis = [], i.yAxis = [], i.animation = Ga ? !1 : eb(f.animation, !0), i.pointCount = i.colorCounter = i.symbolCounter = 0, i.firstRender()
    }, initSeries: function (a) {
        var b, c = this, d = c.options.chart, e = a.type || d.type || d.defaultSeriesType, f = cb[e];
        return f || B(17, !0), b = new f, b.init(this, a), b
    }, isInsidePlot: function (a, b, c) {
        var d = c ? b : a, e = c ? a : b;
        return d >= 0 && d <= this.plotWidth && e >= 0 && e <= this.plotHeight
    }, redraw: function (a) {
        var b, c, d, e = this, f = e.axes, g = e.series, h = e.pointer, i = e.legend, j = e.isDirtyLegend, k = e.hasCartesianSeries, l = e.isDirtyBox, m = g.length, n = m, o = e.renderer, p = o.isHidden(), q = [];
        for (D(a, e), p && e.cloneRenderTo(), e.layOutTitles(); n--;)if (d = g[n], d.options.stacking && (b = !0, d.isDirty)) {
            c = !0;
            break
        }
        if (c)for (n = m; n--;)d = g[n], d.options.stacking && (d.isDirty = !0);
        lb(g, function (a) {
            a.isDirty && "point" === a.options.legendType && (a.updateTotals && a.updateTotals(), j = !0)
        }), j && i.options.enabled && (i.render(), e.isDirtyLegend = !1), b && e.getStacks(), k && (e.isResizing || (e.maxTicks = null, lb(f, function (a) {
            a.setScale()
        }))), e.getMargins(), k && (lb(f, function (a) {
            a.isDirty && (l = !0)
        }), lb(f, function (a) {
            var c = a.min + "," + a.max;
            a.extKey !== c && (a.extKey = c, q.push(function () {
                rb(a, "afterSetExtremes", db(a.eventArgs, a.getExtremes())), delete a.eventArgs
            })), (l || b) && a.redraw()
        })), l && e.drawChartBox(), lb(g, function (a) {
            a.isDirty && a.visible && (!a.isCartesian || a.xAxis) && a.redraw()
        }), h && h.reset(!0), o.draw(), rb(e, "redraw"), p && e.cloneRenderTo(!0), lb(q, function (a) {
            a.call()
        })
    }, get: function (a) {
        var b, c, d, e = this, f = e.axes, g = e.series;
        for (b = 0; b < f.length; b++)if (f[b].options.id === a)return f[b];
        for (b = 0; b < g.length; b++)if (g[b].options.id === a)return g[b];
        for (b = 0; b < g.length; b++)for (d = g[b].points || [], c = 0; c < d.length; c++)if (d[c].id === a)return d[c];
        return null
    }, getAxes: function () {
        var a, b, c = this, d = this.options, e = d.xAxis = l(d.xAxis || {}), f = d.yAxis = l(d.yAxis || {});
        lb(e, function (a, b) {
            a.index = b, a.isX = !0
        }), lb(f, function (a, b) {
            a.index = b
        }), a = e.concat(f), lb(a, function (a) {
            b = new Hb(c, a)
        })
    }, getSelectedPoints: function () {
        var a = [];
        return lb(this.series, function (b) {
            a = a.concat(mb(b.points || [], function (a) {
                return a.selected
            }))
        }), a
    }, getSelectedSeries: function () {
        return mb(this.series, function (a) {
            return a.selected
        })
    }, setTitle: function (b, c, d) {
        var e, f, g = this, h = g.options;
        e = h.title = a(h.title, b), f = h.subtitle = a(h.subtitle, c), lb([
            ["title", b, e],
            ["subtitle", c, f]
        ], function (a) {
            var b = a[0], c = g[b], d = a[1], e = a[2];
            c && d && (g[b] = c = c.destroy()), e && e.text && !c && (g[b] = g.renderer.text(e.text, 0, 0, e.useHTML).attr({align: e.align, "class": Sa + b, zIndex: e.zIndex || 4}).css(e.style).add())
        }), g.layOutTitles(d)
    }, layOutTitles: function (a) {
        var b, c = 0, d = this.title, e = this.subtitle, f = this.options, g = f.title, h = f.subtitle, i = this.renderer, j = this.spacingBox.width - 44;
        d && (d.css({width: (g.width || j) + Ua}).align(db({y: i.fontMetrics(g.style.fontSize, d).b - 3}, g), !1, "spacingBox"), g.floating || g.verticalAlign || (c = d.getBBox().height)), e && (e.css({width: (h.width || j) + Ua}).align(db({y: c + (g.margin - 13) + i.fontMetrics(h.style.fontSize, d).b}, h), !1, "spacingBox"), h.floating || h.verticalAlign || (c = oa(c + e.getBBox().height))), b = this.titleOffset !== c, this.titleOffset = c, !this.isDirtyBox && b && (this.isDirtyBox = b, this.hasRendered && eb(a, !0) && this.isDirtyBox && this.redraw())
    }, getChartSize: function () {
        var a = this, b = a.options.chart, c = b.width, d = b.height, e = a.renderToClone || a.renderTo;
        j(c) || (a.containerWidth = ib(e, "width")), j(d) || (a.containerHeight = ib(e, "height")), a.chartWidth = pa(0, c || a.containerWidth || 600), a.chartHeight = pa(0, eb(d, a.containerHeight > 19 ? a.containerHeight : 400))
    }, cloneRenderTo: function (a) {
        var b = this.renderToClone, c = this.container;
        a ? b && (this.renderTo.appendChild(c), A(b), delete this.renderToClone) : (c && c.parentNode === this.renderTo && this.renderTo.removeChild(c), this.renderToClone = b = this.renderTo.cloneNode(0), m(b, {position: Pa, top: "-9999px", display: "block"}), b.style.setProperty && b.style.setProperty("display", "block", "important"), ja.body.appendChild(b), c && b.appendChild(c))
    }, getContainer: function () {
        var a, d, e, f, g, h, i, j = this, l = j.options, m = l.chart, o = "data-highcharts-chart";
        j.renderTo = f = m.renderTo, i = Sa + Ia++, c(f) && (j.renderTo = f = ja.getElementById(f)), f || B(13, !0), g = b(k(f, o)), !isNaN(g) && Ka[g] && Ka[g].hasRendered && Ka[g].destroy(), k(f, o, j.index), f.innerHTML = "", m.skipClone || f.offsetWidth || j.cloneRenderTo(), j.getChartSize(), d = j.chartWidth, e = j.chartHeight, j.container = a = n(Oa, {className: Sa + "container" + (m.className ? " " + m.className : ""), id: i}, db({position: Qa, overflow: Ra, width: d + Ua, height: e + Ua, textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)"}, m.style), j.renderToClone || f), j._cursor = a.style.cursor, h = ia[m.renderer] || L, j.renderer = new h(a, d, e, m.style, m.forExport, l.exporting && l.exporting.allowHTML), Ga && j.renderer.create(j, a, d, e), j.renderer.chartIndex = j.index
    }, getMargins: function (a) {
        var b = this, c = b.spacing, d = b.margin, e = b.titleOffset;
        b.resetMargins(), e && !j(d[0]) && (b.plotTop = pa(b.plotTop, e + b.options.title.margin + c[0])), b.legend.adjustMargins(d, c), b.extraBottomMargin && (b.marginBottom += b.extraBottomMargin), b.extraTopMargin && (b.plotTop += b.extraTopMargin), a || this.getAxisMargins()
    }, getAxisMargins: function () {
        var a = this, b = a.axisOffset = [0, 0, 0, 0], c = a.margin;
        a.hasCartesianSeries && lb(a.axes, function (a) {
            a.visible && a.getOffset()
        }), lb(ab, function (d, e) {
            j(c[e]) || (a[d] += b[e])
        }), a.setChartSize()
    }, reflow: function (a) {
        var b = this, c = b.options.chart, d = b.renderTo, e = c.width || ib(d, "width"), f = c.height || ib(d, "height"), g = a ? a.target : ka, h = function () {
            b.container && (b.setSize(e, f, !1), b.hasUserSize = null)
        };
        b.hasUserSize || b.isPrinting || !e || !f || g !== ka && g !== ja || ((e !== b.containerWidth || f !== b.containerHeight) && (clearTimeout(b.reflowTimeout), a ? b.reflowTimeout = setTimeout(h, 100) : h()), b.containerWidth = e, b.containerHeight = f)
    }, initReflow: function () {
        var a = this, b = function (b) {
            a.reflow(b)
        };
        pb(ka, "resize", b), pb(a, "destroy", function () {
            qb(ka, "resize", b)
        })
    }, setSize: function (a, b, c) {
        var d, e, f, g, h = this, i = h.renderer;
        h.isResizing += 1, f = function () {
            h && rb(h, "endResize", null, function () {
                h.isResizing -= 1
            })
        }, D(c, h), h.oldChartHeight = h.chartHeight, h.oldChartWidth = h.chartWidth, j(a) && (h.chartWidth = d = pa(0, ma(a)), h.hasUserSize = !!d), j(b) && (h.chartHeight = e = pa(0, ma(b))), g = i.globalAnimation, (g ? tb : m)(h.container, {width: d + Ua, height: e + Ua}, g), h.setChartSize(!0), i.setSize(d, e, c), h.maxTicks = null, lb(h.axes, function (a) {
            a.isDirty = !0, a.setScale()
        }), lb(h.series, function (a) {
            a.isDirty = !0
        }), h.isDirtyLegend = !0, h.isDirtyBox = !0, h.layOutTitles(), h.getMargins(), h.redraw(c), h.oldChartHeight = null, rb(h, "resize"), g = i.globalAnimation, g === !1 ? f() : setTimeout(f, g && g.duration || 500)
    }, setChartSize: function (a) {
        var b, c, d, e, f, g, h, i = this, j = i.inverted, k = i.renderer, l = i.chartWidth, m = i.chartHeight, n = i.options.chart, o = i.spacing, p = i.clipOffset;
        i.plotLeft = d = ma(i.plotLeft), i.plotTop = e = ma(i.plotTop), i.plotWidth = f = pa(0, ma(l - d - i.marginRight)), i.plotHeight = g = pa(0, ma(m - e - i.marginBottom)), i.plotSizeX = j ? g : f, i.plotSizeY = j ? f : g, i.plotBorderWidth = n.plotBorderWidth || 0, i.spacingBox = k.spacingBox = {x: o[3], y: o[0], width: l - o[3] - o[1], height: m - o[0] - o[2]}, i.plotBox = k.plotBox = {x: d, y: e, width: f, height: g}, h = 2 * na(i.plotBorderWidth / 2), b = oa(pa(h, p[3]) / 2), c = oa(pa(h, p[0]) / 2), i.clipBox = {x: b, y: c, width: na(i.plotSizeX - pa(h, p[1]) / 2 - b), height: pa(0, na(i.plotSizeY - pa(h, p[2]) / 2 - c))}, a || lb(i.axes, function (a) {
            a.setAxisSize(), a.setAxisTranslation()
        })
    }, resetMargins: function () {
        var a = this;
        lb(ab, function (b, c) {
            a[b] = eb(a.margin[c], a.spacing[c])
        }), a.axisOffset = [0, 0, 0, 0], a.clipOffset = [0, 0, 0, 0]
    }, drawChartBox: function () {
        var a, b, c = this, d = c.options.chart, e = c.renderer, f = c.chartWidth, g = c.chartHeight, h = c.chartBackground, i = c.plotBackground, j = c.plotBorder, k = c.plotBGImage, l = d.borderWidth || 0, m = d.backgroundColor, n = d.plotBackgroundColor, o = d.plotBackgroundImage, p = d.plotBorderWidth || 0, q = c.plotLeft, r = c.plotTop, s = c.plotWidth, t = c.plotHeight, u = c.plotBox, v = c.clipRect, w = c.clipBox;
        a = l + (d.shadow ? 8 : 0), (l || m) && (h ? h.animate(h.crisp({width: f - a, height: g - a})) : (b = {fill: m || Va}, l && (b.stroke = d.borderColor, b["stroke-width"] = l), c.chartBackground = e.rect(a / 2, a / 2, f - a, g - a, d.borderRadius, l).attr(b).addClass(Sa + "background").add().shadow(d.shadow))), n && (i ? i.animate(u) : c.plotBackground = e.rect(q, r, s, t, 0).attr({fill: n}).add().shadow(d.plotShadow)), o && (k ? k.animate(u) : c.plotBGImage = e.image(o, q, r, s, t).add()), v ? v.animate({width: w.width, height: w.height}) : c.clipRect = e.clipRect(w), p && (j ? j.animate(j.crisp({x: q, y: r, width: s, height: t, strokeWidth: -p})) : c.plotBorder = e.rect(q, r, s, t, 0, -p).attr({stroke: d.plotBorderColor, "stroke-width": p, fill: Va, zIndex: 1}).add()), c.isDirtyBox = !1
    }, propFromSeries: function () {
        var a, b, c, d = this, e = d.options.chart, f = d.options.series;
        lb(["inverted", "angular", "polar"], function (g) {
            for (a = cb[e.type || e.defaultSeriesType], c = d[g] || e[g] || a && a.prototype[g], b = f && f.length; !c && b--;)a = cb[f[b].type], a && a.prototype[g] && (c = !0);
            d[g] = c
        })
    }, linkSeries: function () {
        var a = this, b = a.series;
        lb(b, function (a) {
            a.linkedSeries.length = 0
        }), lb(b, function (b) {
            var d = b.options.linkedTo;
            c(d) && (d = ":previous" === d ? a.series[b.index - 1] : a.get(d), d && (d.linkedSeries.push(b), b.linkedParent = d, b.visible = eb(b.options.visible, d.options.visible, b.visible)))
        })
    }, renderSeries: function () {
        lb(this.series, function (a) {
            a.translate(), a.render()
        })
    }, renderLabels: function () {
        var a = this, c = a.options.labels;
        c.items && lb(c.items, function (d) {
            var e = db(c.style, d.style), f = b(e.left) + a.plotLeft, g = b(e.top) + a.plotTop + 12;
            delete e.left, delete e.top, a.renderer.text(d.html, f, g).attr({zIndex: 2}).css(e).add()
        })
    }, render: function () {
        var a, b, c, d, e = this, f = e.axes, g = e.renderer, h = e.options;
        e.setTitle(), e.legend = new Pb(e, h.legend), e.getStacks && e.getStacks(), e.getMargins(!0), e.setChartSize(), a = e.plotWidth, b = e.plotHeight = e.plotHeight - 13, lb(f, function (a) {
            a.setScale()
        }), e.getAxisMargins(), c = a / e.plotWidth > 1.1, d = b / e.plotHeight > 1.1, (c || d) && (e.maxTicks = null, lb(f, function (a) {
            (a.horiz && c || !a.horiz && d) && a.setTickInterval(!0)
        }), e.getMargins()), e.drawChartBox(), e.hasCartesianSeries && lb(f, function (a) {
            a.visible && a.render()
        }), e.seriesGroup || (e.seriesGroup = g.g("series-group").attr({zIndex: 3}).add()), e.renderSeries(), e.renderLabels(), e.showCredits(h.credits), e.hasRendered = !0
    }, showCredits: function (a) {
        a.enabled && !this.credits && (this.credits = this.renderer.text(a.text, 0, 0).on("click", function () {
            a.href && (location.href = a.href)
        }).attr({align: a.position.align, zIndex: 8}).css(a.style).add().align(a.position))
    }, destroy: function () {
        var a, b = this, c = b.axes, d = b.series, e = b.container, f = e && e.parentNode;
        for (rb(b, "destroy"), Ka[b.index] = K, La--, b.renderTo.removeAttribute("data-highcharts-chart"), qb(b), a = c.length; a--;)c[a] = c[a].destroy();
        for (a = d.length; a--;)d[a] = d[a].destroy();
        lb(["title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "scroller", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer"], function (a) {
            var c = b[a];
            c && c.destroy && (b[a] = c.destroy())
        }), e && (e.innerHTML = "", qb(e), f && A(e));
        for (a in b)delete b[a]
    }, isReadyToRender: function () {
        var a = this;
        return!Ea && ka == ka.top && "complete" !== ja.readyState || Ga && !ka.canvg ? (Ga ? Gb.push(function () {
            a.firstRender()
        }, a.options.global.canvasToolsURL) : ja.attachEvent("onreadystatechange", function () {
            ja.detachEvent("onreadystatechange", a.firstRender), "complete" === ja.readyState && a.firstRender()
        }), !1) : !0
    }, firstRender: function () {
        var a = this, b = a.options, c = a.callback;
        a.isReadyToRender() && (a.getContainer(), rb(a, "init"), a.resetMargins(), a.setChartSize(), a.propFromSeries(), a.getAxes(), lb(b.series || [], function (b) {
            a.initSeries(b)
        }), a.linkSeries(), rb(a, "beforeRender"), ia.Pointer && (a.pointer = new Kb(a, b)), a.render(), a.renderer.draw(), c && c.apply(a, [a]), lb(a.callbacks, function (b) {
            a.index !== K && b.apply(a, [a])
        }), rb(a, "load"), a.cloneRenderTo(!0))
    }, splashArray: function (a, b) {
        var c = b[a], e = d(c) ? c : [c, c, c, c];
        return[eb(b[a + "Top"], e[0]), eb(b[a + "Right"], e[1]), eb(b[a + "Bottom"], e[2]), eb(b[a + "Left"], e[3])]
    }};
    var Sb = ia.CenteredSeriesMixin = {getCenter: function () {
        var a, b, c, d = this.options, e = this.chart, f = 2 * (d.slicedOffset || 0), g = e.plotWidth - 2 * f, h = e.plotHeight - 2 * f, i = d.center, j = [eb(i[0], "50%"), eb(i[1], "50%"), d.size || "100%", d.innerSize || 0], k = qa(g, h);
        for (b = 0; 4 > b; ++b)c = j[b], a = 2 > b || 2 === b && /%$/.test(c), j[b] = q(c, [g, h, k, j[2]][b]) + (a ? f : 0);
        return j[3] > j[2] && (j[3] = j[2]), j
    }}, Tb = function () {
    };
    Tb.prototype = {init: function (a, b, c) {
        var d, e = this;
        return e.series = a, e.color = a.color, e.applyOptions(b, c), e.pointAttr = {}, a.options.colorByPoint && (d = a.options.colors || a.chart.options.colors, e.color = e.color || d[a.colorCounter++], a.colorCounter === d.length && (a.colorCounter = 0)), a.chart.pointCount++, e
    }, applyOptions: function (a, b) {
        var c = this, d = c.series, e = d.options.pointValKey || d.pointValKey;
        return a = Tb.prototype.optionsToObject.call(this, a), db(c, a), c.options = c.options ? db(c.options, a) : a, e && (c.y = c[e]), c.x === K && d && (c.x = b === K ? d.autoIncrement() : b), c
    }, optionsToObject: function (a) {
        var b, c = {}, d = this.series, f = d.options.keys, g = f || d.pointArrayMap || ["y"], h = g.length, i = 0, j = 0;
        if ("number" == typeof a || null === a)c[g[0]] = a; else if (e(a))for (!f && a.length > h && (b = typeof a[0], "string" === b ? c.name = a[0] : "number" === b && (c.x = a[0]), i++); h > j;)f && void 0 === a[i] || (c[g[j]] = a[i]), i++, j++; else"object" == typeof a && (c = a, a.dataLabels && (d._hasPointLabels = !0), a.marker && (d._hasPointMarkers = !0));
        return c
    }, destroy: function () {
        var a, b = this, c = b.series, d = c.chart, e = d.hoverPoints;
        d.pointCount--, e && (b.setState(), i(e, b), e.length || (d.hoverPoints = null)), b === d.hoverPoint && b.onMouseOut(), (b.graphic || b.dataLabel) && (qb(b), b.destroyElements()), b.legendItem && d.legend.destroyItem(b);
        for (a in b)b[a] = null
    }, destroyElements: function () {
        for (var a, b = this, c = ["graphic", "dataLabel", "dataLabelUpper", "connector", "shadowGroup"], d = 6; d--;)a = c[d], b[a] && (b[a] = b[a].destroy())
    }, getLabelConfig: function () {
        return{x: this.category, y: this.y, color: this.color, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal}
    }, tooltipFormatter: function (a) {
        var b = this.series, c = b.tooltipOptions, d = eb(c.valueDecimals, ""), e = c.valuePrefix || "", f = c.valueSuffix || "";
        return lb(b.pointArrayMap || ["y"], function (b) {
            b = "{point." + b, (e || f) && (a = a.replace(b + "}", e + b + "}" + f)), a = a.replace(b + "}", b + ":,." + d + "f}")
        }), t(a, {point: this, series: this.series})
    }, firePointEvent: function (a, b, c) {
        var d = this, e = this.series, f = e.options;
        (f.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents(), "click" === a && f.allowPointSelect && (c = function (a) {
            d.select && d.select(null, a.ctrlKey || a.metaKey || a.shiftKey)
        }), rb(this, a, b, c)
    }, visible: !0};
    var Ub = ia.Series = function () {
    };
    Ub.prototype = {isCartesian: !0, type: "line", pointClass: Tb, sorted: !0, requireSorting: !0, pointAttrToOptions: {stroke: "lineColor", "stroke-width": "lineWidth", fill: "fillColor", r: "radius"}, directTouch: !1, axisTypes: ["xAxis", "yAxis"], colorCounter: 0, parallelArrays: ["x", "y"], init: function (a, b) {
        var c, d, e = this, f = a.series, g = function (a, b) {
            return eb(a.options.index, a._i) - eb(b.options.index, b._i)
        };
        e.chart = a, e.options = b = e.setOptions(b), e.linkedSeries = [], e.bindAxes(), db(e, {name: b.name, state: Za, pointAttr: {}, visible: b.visible !== !1, selected: b.selected === !0}), Ga && (b.animation = !1), d = b.events;
        for (c in d)pb(e, c, d[c]);
        (d && d.click || b.point && b.point.events && b.point.events.click || b.allowPointSelect) && (a.runTrackerClick = !0), e.getColor(), e.getSymbol(), lb(e.parallelArrays, function (a) {
            e[a + "Data"] = []
        }), e.setData(b.data, !1), e.isCartesian && (a.hasCartesianSeries = !0), f.push(e), e._i = f.length - 1, w(f, g), this.yAxis && w(this.yAxis.series, g), lb(f, function (a, b) {
            a.index = b, a.name = a.name || "Series " + (b + 1)
        })
    }, bindAxes: function () {
        var a, b = this, c = b.options, d = b.chart;
        lb(b.axisTypes || [], function (e) {
            lb(d[e], function (d) {
                a = d.options, (c[e] === a.index || c[e] !== K && c[e] === a.id || c[e] === K && 0 === a.index) && (d.series.push(b), b[e] = d, d.isDirty = !0)
            }), b[e] || b.optionalAxis === e || B(18, !0)
        })
    }, updateParallelArrays: function (a, b) {
        var c = a.series, d = arguments, e = "number" == typeof b ? function (d) {
            var e = "y" === d && c.toYData ? c.toYData(a) : a[d];
            c[d + "Data"][b] = e
        } : function (a) {
            Array.prototype[b].apply(c[a + "Data"], Array.prototype.slice.call(d, 2))
        };
        lb(c.parallelArrays, e)
    }, autoIncrement: function () {
        var a, b, c = this.options, d = this.xIncrement, e = c.pointIntervalUnit;
        return d = eb(d, c.pointStart, 0), this.pointInterval = b = eb(this.pointInterval, c.pointInterval, 1), ("month" === e || "year" === e) && (a = new T(d), a = "month" === e ? +a[ga](a[_]() + b) : +a[ha](a[aa]() + b), b = a - d), this.xIncrement = d + b, d
    }, getSegments: function () {
        var a, b = this, c = -1, d = [], e = b.points, f = e.length;
        if (f)if (b.options.connectNulls) {
            for (a = f; a--;)null === e[a].y && e.splice(a, 1);
            e.length && (d = [e])
        } else lb(e, function (a, b) {
            null === a.y ? (b > c + 1 && d.push(e.slice(c + 1, b)), c = b) : b === f - 1 && d.push(e.slice(c + 1, b + 1))
        });
        b.segments = d
    }, setOptions: function (b) {
        var c, d, e = this.chart, f = e.options, g = f.plotOptions, h = e.userOptions || {}, i = h.plotOptions || {}, k = g[this.type];
        return this.userOptions = b, c = a(k, g.series, b), this.tooltipOptions = a(O.tooltip, O.plotOptions[this.type].tooltip, h.tooltip, i.series && i.series.tooltip, i[this.type] && i[this.type].tooltip, b.tooltip), null === k.marker && delete c.marker, this.zoneAxis = c.zoneAxis, d = this.zones = (c.zones || []).slice(), !c.negativeColor && !c.negativeFillColor || c.zones || d.push({value: c[this.zoneAxis + "Threshold"] || c.threshold || 0, color: c.negativeColor, fillColor: c.negativeFillColor}), d.length && j(d[d.length - 1].value) && d.push({color: this.color, fillColor: this.fillColor}), c
    }, getCyclic: function (a, b, c) {
        var d, e = this.userOptions, f = "_" + a + "Index", g = a + "Counter";
        b || (j(e[f]) ? d = e[f] : (e[f] = d = this.chart[g] % c.length, this.chart[g] += 1), b = c[d]), this[a] = b
    }, getColor: function () {
        this.options.colorByPoint ? this.options.color = null : this.getCyclic("color", this.options.color || vb[this.type].color, this.chart.options.colors)
    }, getSymbol: function () {
        var a = this.options.marker;
        this.getCyclic("symbol", a.symbol, this.chart.options.symbols), /^url/.test(this.symbol) && (a.radius = 0)
    }, drawLegendSymbol: Qb.drawLineMarker, setData: function (a, b, d, g) {
        var h, i, k, l = this, m = l.points, n = m && m.length || 0, o = l.options, p = l.chart, q = null, r = l.xAxis, s = r && !!r.categories, t = o.turboThreshold, u = this.xData, v = this.yData, w = l.pointArrayMap, x = w && w.length;
        if (a = a || [], h = a.length, b = eb(b, !0), g !== !1 && h && n === h && !l.cropped && !l.hasGroupedData && l.visible)lb(a, function (a, b) {
            m[b].update && m[b].update(a, !1, null, !1)
        }); else {
            if (l.xIncrement = null, l.pointRange = s ? 1 : o.pointRange, l.colorCounter = 0, lb(this.parallelArrays, function (a) {
                l[a + "Data"].length = 0
            }), t && h > t) {
                for (i = 0; null === q && h > i;)q = a[i], i++;
                if (f(q)) {
                    var y = eb(o.pointStart, 0), z = eb(o.pointInterval, 1);
                    for (i = 0; h > i; i++)u[i] = y, v[i] = a[i], y += z;
                    l.xIncrement = y
                } else if (e(q))if (x)for (i = 0; h > i; i++)k = a[i], u[i] = k[0], v[i] = k.slice(1, x + 1); else for (i = 0; h > i; i++)k = a[i], u[i] = k[0], v[i] = k[1]; else B(12)
            } else for (i = 0; h > i; i++)a[i] !== K && (k = {series: l}, l.pointClass.prototype.applyOptions.apply(k, [a[i]]), l.updateParallelArrays(k, i), s && j(k.name) && (r.names[k.x] = k.name));
            for (c(v[0]) && B(14, !0), l.data = [], l.options.data = a, i = n; i--;)m[i] && m[i].destroy && m[i].destroy();
            r && (r.minRange = r.userMinRange), l.isDirty = l.isDirtyData = p.isDirtyBox = !0, d = !1
        }
        "point" === o.legendType && (this.processData(), this.generatePoints()), b && p.redraw(d)
    }, processData: function (a) {
        var b, c, d, e, f, g, h, i, j = this, k = j.xData, l = j.yData, m = k.length, n = 0, o = j.xAxis, p = j.options, q = p.cropThreshold, r = j.getExtremesFromAll || p.getExtremesFromAll, s = j.isCartesian;
        if (s && !j.isDirty && !o.isDirty && !j.yAxis.isDirty && !a)return!1;
        for (o && (g = o.getExtremes(), h = g.min, i = g.max), s && j.sorted && !r && (!q || m > q || j.forceCrop) && (k[m - 1] < h || k[0] > i ? (k = [], l = []) : (k[0] < h || k[m - 1] > i) && (b = this.cropData(j.xData, j.yData, h, i), k = b.xData, l = b.yData, n = b.start, c = !0)), f = k.length - 1; f >= 0; f--)d = k[f] - k[f - 1], d > 0 && (e === K || e > d) ? e = d : 0 > d && j.requireSorting && B(15);
        j.cropped = c, j.cropStart = n, j.processedXData = k, j.processedYData = l, null === p.pointRange && (j.pointRange = e || 1), j.closestPointRange = e
    }, cropData: function (a, b, c, d) {
        var e, f = a.length, g = 0, h = f, i = eb(this.cropShoulder, 1);
        for (e = 0; f > e; e++)if (a[e] >= c) {
            g = pa(0, e - i);
            break
        }
        for (; f > e; e++)if (a[e] > d) {
            h = e + i;
            break
        }
        return{xData: a.slice(g, h), yData: b.slice(g, h), start: g, end: h}
    }, generatePoints: function () {
        var a, b, c, d, e = this, f = e.options, g = f.data, h = e.data, i = e.processedXData, j = e.processedYData, k = e.pointClass, m = i.length, n = e.cropStart || 0, o = e.hasGroupedData, p = [];
        if (!h && !o) {
            var q = [];
            q.length = g.length, h = e.data = q
        }
        for (d = 0; m > d; d++)b = n + d, o ? p[d] = (new k).init(e, [i[d]].concat(l(j[d]))) : (h[b] ? c = h[b] : g[b] !== K && (h[b] = c = (new k).init(e, g[b], i[d])), p[d] = c), p[d].index = b;
        if (h && (m !== (a = h.length) || o))for (d = 0; a > d; d++)d !== n || o || (d += m), h[d] && (h[d].destroyElements(), h[d].plotX = K);
        e.data = h, e.points = p
    }, getExtremes: function (a) {
        var b, c, d, e, f, g, h, i = this.xAxis, j = this.yAxis, k = this.processedXData, l = [], m = 0, n = i.getExtremes(), o = n.min, p = n.max;
        for (a = a || this.stackedYData || this.processedYData, b = a.length, g = 0; b > g; g++)if (e = k[g], f = a[g], c = null !== f && f !== K && (!j.isLog || f.length || f > 0), d = this.getExtremesFromAll || this.options.getExtremesFromAll || this.cropped || (k[g + 1] || e) >= o && (k[g - 1] || e) <= p, c && d)if (h = f.length)for (; h--;)null !== f[h] && (l[m++] = f[h]); else l[m++] = f;
        this.dataMin = x(l), this.dataMax = y(l)
    }, translate: function () {
        this.processedXData || this.processData(), this.generatePoints();
        var a, b, c, d, e, g = this, h = g.options, i = h.stacking, k = g.xAxis, l = k.categories, m = g.yAxis, n = g.points, o = n.length, p = !!g.modifyValue, q = h.pointPlacement, r = "between" === q || f(q), s = h.threshold, t = h.startFromThreshold ? s : 0, u = Number.MAX_VALUE;
        for (a = 0; o > a; a++) {
            var v, w, x = n[a], y = x.x, z = x.y, A = x.low, C = i && m.stacks[(g.negStacks && (t ? 0 : s) > z ? "-" : "") + g.stackKey];
            m.isLog && null !== z && 0 >= z && (x.y = z = null, B(10)), x.plotX = b = qa(pa(-1e5, k.translate(y, 0, 0, 0, 1, q, "flags" === this.type)), 1e5), i && g.visible && C && C[y] && (e = g.getStackIndicator(e, y, g.index), v = C[y], w = v.points[e.key], A = w[0], z = w[1], A === t && (A = eb(s, m.min)), m.isLog && 0 >= A && (A = null), x.total = x.stackTotal = v.total, x.percentage = v.total && x.y / v.total * 100, x.stackY = z, v.setOffset(g.pointXOffset || 0, g.barW || 0)), x.yBottom = j(A) ? m.translate(A, 0, 1, 0, 1) : null, p && (z = g.modifyValue(z, x)), x.plotY = c = "number" == typeof z && z !== 1 / 0 ? qa(pa(-1e5, m.translate(z, 0, 1, 0, 1)), 1e5) : K, x.isInside = c !== K && c >= 0 && c <= m.len && b >= 0 && b <= k.len, x.clientX = r ? k.translate(y, 0, 0, 0, 1) : b, x.negative = x.y < (s || 0), x.category = l && l[x.x] !== K ? l[x.x] : x.x, a && (u = qa(u, ra(b - d))), d = b
        }
        g.closestPointRangePx = u, g.getSegments()
    }, setClip: function (a) {
        var b = this.chart, c = this.options, d = b.renderer, e = b.inverted, f = this.clipBox, g = f || b.clipBox, h = this.sharedClipKey || ["_sharedClip", a && a.duration, a && a.easing, g.height, c.xAxis, c.yAxis].join(","), i = b[h], j = b[h + "m"];
        i || (a && (g.width = 0, b[h + "m"] = j = d.clipRect(-99, e ? -b.plotLeft : -b.plotTop, 99, e ? b.chartWidth : b.chartHeight)), b[h] = i = d.clipRect(g)), a && (i.count += 1), c.clip !== !1 && (this.group.clip(a || f ? i : b.clipRect), this.markerGroup.clip(j), this.sharedClipKey = h), a || (i.count -= 1, i.count <= 0 && h && b[h] && (f || (b[h] = b[h].destroy()), b[h + "m"] && (b[h + "m"] = b[h + "m"].destroy())))
    }, animate: function (a) {
        var b, c, e = this, f = e.chart, g = e.options.animation;
        g && !d(g) && (g = vb[e.type].animation), a ? e.setClip(g) : (c = this.sharedClipKey, b = f[c], b && b.animate({width: f.plotSizeX}, g), f[c + "m"] && f[c + "m"].animate({width: f.plotSizeX + 99}, g), e.animate = null)
    }, afterAnimate: function () {
        this.setClip(), rb(this, "afterAnimate")
    }, drawPoints: function () {
        var a, b, c, d, e, f, g, h, i, j, k, l, m, n = this, o = n.points, p = n.chart, q = n.options, r = q.marker, s = n.pointAttr[""], t = n.markerGroup, u = n.xAxis, v = eb(r.enabled, u.isRadial, n.closestPointRangePx > 2 * r.radius);
        if (r.enabled !== !1 || n._hasPointMarkers)for (d = o.length; d--;)e = o[d], b = na(e.plotX), c = e.plotY, i = e.graphic, j = e.marker || {}, k = !!e.marker, l = v && j.enabled === K || j.enabled, m = e.isInside, l && c !== K && !isNaN(c) && null !== e.y ? (a = e.pointAttr[e.selected ? _a : Za] || s, f = a.r, g = eb(j.symbol, n.symbol), h = 0 === g.indexOf("url"), i ? i[m ? "show" : "hide"](!0).animate(db({x: b - f, y: c - f}, i.symbolName ? {width: 2 * f, height: 2 * f} : {})) : m && (f > 0 || h) && (e.graphic = i = p.renderer.symbol(g, b - f, c - f, 2 * f, 2 * f, k ? j : r).attr(a).add(t))) : i && (e.graphic = i.destroy())
    }, convertAttribs: function (a, b, c, d) {
        var e, f, g = this.pointAttrToOptions, h = {};
        a = a || {}, b = b || {}, c = c || {}, d = d || {};
        for (e in g)f = g[e], h[e] = eb(a[f], b[e], c[e], d[e]);
        return h
    }, getAttribs: function () {
        var a, b, c, d, e, f, g, h, i = this, k = i.options, l = vb[i.type].marker ? k.marker : k, m = l.states, n = m[$a], o = i.color, p = i.options.negativeColor, q = {stroke: o, fill: o}, r = i.points || [], s = [], t = i.pointAttrToOptions, u = i.hasPointSpecificOptions, v = l.lineColor, w = l.fillColor, x = k.turboThreshold, y = i.zones, z = i.zoneAxis || "y";
        if (k.marker ? (n.radius = n.radius || l.radius + n.radiusPlus, n.lineWidth = n.lineWidth || l.lineWidth + n.lineWidthPlus) : (n.color = n.color || Ab(n.color || o).brighten(n.brightness).get(), n.negativeColor = n.negativeColor || Ab(n.negativeColor || p).brighten(n.brightness).get()), s[Za] = i.convertAttribs(l, q), lb([$a, _a], function (a) {
            s[a] = i.convertAttribs(m[a], s[Za])
        }), i.pointAttr = s, b = r.length, !x || x > b || u)for (; b--;) {
            if (e = r[b], l = e.options && e.options.marker || e.options, l && l.enabled === !1 && (l.radius = 0), y.length) {
                for (c = 0, d = y[c]; e[z] >= d.value;)d = y[++c];
                e.color = e.fillColor = eb(d.color, i.color)
            }
            if (u = k.colorByPoint || e.color, e.options)for (h in t)j(l[t[h]]) && (u = !0);
            u ? (l = l || {}, f = [], m = l.states || {}, a = m[$a] = m[$a] || {}, (!k.marker || e.negative && !a.fillColor && !n.fillColor) && (a[i.pointAttrToOptions.fill] = a.color || !e.options.color && n[e.negative && p ? "negativeColor" : "color"] || Ab(e.color).brighten(a.brightness || n.brightness).get()), g = {color: e.color}, w || (g.fillColor = e.color), v || (g.lineColor = e.color), l.hasOwnProperty("color") && !l.color && delete l.color, f[Za] = i.convertAttribs(db(g, l), s[Za]), f[$a] = i.convertAttribs(m[$a], s[$a], f[Za]), f[_a] = i.convertAttribs(m[_a], s[_a], f[Za])) : f = s, e.pointAttr = f
        }
    }, destroy: function () {
        var a, b, c, d, e, f = this, g = f.chart, h = /AppleWebKit\/533/.test(wa), j = f.data || [];
        for (rb(f, "destroy"), qb(f), lb(f.axisTypes || [], function (a) {
            e = f[a], e && (i(e.series, f), e.isDirty = e.forceRedraw = !0)
        }), f.legendItem && f.chart.legend.destroyItem(f), b = j.length; b--;)c = j[b], c && c.destroy && c.destroy();
        f.points = null, clearTimeout(f.animationTimeout);
        for (d in f)f[d]instanceof H && !f[d].survive && (a = h && "group" === d ? "hide" : "destroy", f[d][a]());
        g.hoverSeries === f && (g.hoverSeries = null), i(g.series, f);
        for (d in f)delete f[d]
    }, getSegmentPath: function (a) {
        var b = this, c = [], d = b.options.step;
        return lb(a, function (e, f) {
            var g, h = e.plotX, i = e.plotY;
            b.getPointSpline ? c.push.apply(c, b.getPointSpline(a, e, f)) : (c.push(f ? Xa : Wa), d && f && (g = a[f - 1], "right" === d ? c.push(g.plotX, i, Xa) : "center" === d ? c.push((g.plotX + h) / 2, g.plotY, Xa, (g.plotX + h) / 2, i, Xa) : c.push(h, g.plotY, Xa)), c.push(e.plotX, e.plotY))
        }), c
    }, getGraphPath: function () {
        var a, b = this, c = [], d = [];
        return lb(b.segments, function (e) {
            a = b.getSegmentPath(e), e.length > 1 ? c = c.concat(a) : d.push(e[0])
        }), b.singlePoints = d, b.graphPath = c, c
    }, drawGraph: function () {
        var a = this, b = this.options, c = [
            ["graph", b.lineColor || this.color, b.dashStyle]
        ], d = b.lineWidth, e = "square" !== b.linecap, f = this.getGraphPath(), g = this.fillGraph && this.color || Va, h = this.zones;
        lb(h, function (d, e) {
            c.push(["zoneGraph" + e, d.color || a.color, d.dashStyle || b.dashStyle])
        }), lb(c, function (c, h) {
            var i, j = c[0], k = a[j];
            k ? k.animate({d: f}) : (d || g) && f.length && (i = {stroke: c[1], "stroke-width": d, fill: g, zIndex: 1}, c[2] ? i.dashstyle = c[2] : e && (i["stroke-linecap"] = i["stroke-linejoin"] = "round"), a[j] = a.chart.renderer.path(f).attr(i).add(a.group).shadow(2 > h && b.shadow))
        })
    }, applyZones: function () {
        var a, b, c, d, e, f, g, h = this, i = this.chart, j = i.renderer, k = this.zones, l = this.clips || [], m = this.graph, n = this.area, o = pa(i.chartWidth, i.chartHeight), p = this[(this.zoneAxis || "y") + "Axis"], q = p.reversed, r = i.inverted, s = p.horiz, t = !1;
        k.length && (m || n) && p.min !== K && (m && m.hide(), n && n.hide(), d = p.getExtremes(), lb(k, function (k, u) {
            a = q ? s ? i.plotWidth : 0 : s ? 0 : p.toPixels(d.min), a = qa(pa(eb(b, a), 0), o), b = qa(pa(ma(p.toPixels(eb(k.value, d.max), !0)), 0), o), t && (a = b = p.toPixels(d.max)), e = Math.abs(a - b), f = qa(a, b), g = pa(a, b), p.isXAxis ? (c = {x: r ? g : f, y: 0, width: e, height: o}, s || (c.x = i.plotHeight - c.x)) : (c = {x: 0, y: r ? g : f, width: o, height: e}, s && (c.y = i.plotWidth - c.y)), i.inverted && j.isVML && (c = p.isXAxis ? {x: 0, y: q ? f : g, height: c.width, width: i.chartWidth} : {x: c.y - i.plotLeft - i.spacingBox.x, y: 0, width: c.height, height: i.chartHeight}), l[u] ? l[u].animate(c) : (l[u] = j.clipRect(c), m && h["zoneGraph" + u].clip(l[u]), n && h["zoneArea" + u].clip(l[u])), t = k.value > d.max
        }), this.clips = l)
    }, invertGroups: function () {
        function a() {
            var a = {width: b.yAxis.len, height: b.xAxis.len};
            lb(["group", "markerGroup"], function (c) {
                b[c] && b[c].attr(a).invert()
            })
        }

        var b = this, c = b.chart;
        b.xAxis && (pb(c, "resize", a), pb(b, "destroy", function () {
            qb(c, "resize", a)
        }), a(), b.invertGroups = a)
    }, plotGroup: function (a, b, c, d, e) {
        var f = this[a], g = !f;
        return g && (this[a] = f = this.chart.renderer.g(b).attr({visibility: c, zIndex: d || .1}).add(e), f.addClass("highcharts-series-" + this.index)), f[g ? "attr" : "animate"](this.getPlotBox()), f
    }, getPlotBox: function () {
        var a = this.chart, b = this.xAxis, c = this.yAxis;
        return a.inverted && (b = c, c = this.xAxis), {translateX: b ? b.left : a.plotLeft, translateY: c ? c.top : a.plotTop, scaleX: 1, scaleY: 1}
    }, render: function () {
        var a, b = this, c = b.chart, d = b.options, e = d.animation, f = e && !!b.animate && c.renderer.isSVG && eb(e.duration, 500) || 0, g = b.visible ? Ta : Ra, h = d.zIndex, i = b.hasRendered, j = c.seriesGroup;
        a = b.plotGroup("group", "series", g, h, j), b.markerGroup = b.plotGroup("markerGroup", "markers", g, h, j), f && b.animate(!0), b.getAttribs(), a.inverted = b.isCartesian ? c.inverted : !1, b.drawGraph && (b.drawGraph(), b.applyZones()), lb(b.points, function (a) {
            a.redraw && a.redraw()
        }), b.drawDataLabels && b.drawDataLabels(), b.visible && b.drawPoints(), b.drawTracker && b.options.enableMouseTracking !== !1 && b.drawTracker(), c.inverted && b.invertGroups(), d.clip === !1 || b.sharedClipKey || i || a.clip(c.clipRect), f && b.animate(),
            i || (f ? b.animationTimeout = setTimeout(function () {
            b.afterAnimate()
        }, f) : b.afterAnimate()), b.isDirty = b.isDirtyData = !1, b.hasRendered = !0
    }, redraw: function () {
        var a = this, b = a.chart, c = a.isDirtyData, d = a.isDirty, e = a.group, f = a.xAxis, g = a.yAxis;
        e && (b.inverted && e.attr({width: b.plotWidth, height: b.plotHeight}), e.animate({translateX: eb(f && f.left, b.plotLeft), translateY: eb(g && g.top, b.plotTop)})), a.translate(), a.render(), c && rb(a, "updatedData"), (d || c) && delete this.kdTree
    }, kdDimensions: 1, kdAxisArray: ["clientX", "plotY"], searchPoint: function (a, b) {
        var c = this, d = c.xAxis, e = c.yAxis, f = c.chart.inverted;
        return this.searchKDTree({clientX: f ? d.len - a.chartY + d.pos : a.chartX - d.pos, plotY: f ? e.len - a.chartX + e.pos : a.chartY - e.pos}, b)
    }, buildKDTree: function () {
        function a(b, d, e) {
            var f, g, h = b && b.length;
            return h ? (f = c.kdAxisArray[d % e], b.sort(function (a, b) {
                return a[f] - b[f]
            }), g = Math.floor(h / 2), {point: b[g], left: a(b.slice(0, g), d + 1, e), right: a(b.slice(g + 1), d + 1, e)}) : void 0
        }

        function b() {
            var b = mb(c.points || [], function (a) {
                return null !== a.y
            });
            c.kdTree = a(b, d, d)
        }

        var c = this, d = c.kdDimensions;
        delete c.kdTree, c.options.kdSync ? b() : setTimeout(b)
    }, searchKDTree: function (a, b) {
        function c(a, b) {
            var c = j(a[f]) && j(b[f]) ? Math.pow(a[f] - b[f], 2) : null, d = j(a[g]) && j(b[g]) ? Math.pow(a[g] - b[g], 2) : null, e = (c || 0) + (d || 0);
            b.dist = j(e) ? Math.sqrt(e) : Number.MAX_VALUE, b.distX = j(c) ? Math.sqrt(c) : Number.MAX_VALUE
        }

        function d(a, b, f, g) {
            var i, j, k, l, m, n = b.point, o = e.kdAxisArray[f % g], p = n;
            return c(a, n), i = a[o] - n[o], j = 0 > i ? "left" : "right", k = 0 > i ? "right" : "left", b[j] && (l = d(a, b[j], f + 1, g), p = l[h] < p[h] ? l : n), b[k] && Math.sqrt(i * i) < p[h] && (m = d(a, b[k], f + 1, g), p = m[h] < p[h] ? m : p), p
        }

        var e = this, f = this.kdAxisArray[0], g = this.kdAxisArray[1], h = b ? "distX" : "dist";
        return this.kdTree || this.buildKDTree(), this.kdTree ? d(a, this.kdTree, this.kdDimensions, this.kdDimensions) : void 0
    }}, J.prototype = {destroy: function () {
        z(this, this.axis)
    }, render: function (a) {
        var b = this.options, c = b.format, d = c ? t(c, this) : b.formatter.call(this);
        this.label ? this.label.attr({text: d, visibility: Ra}) : this.label = this.axis.chart.renderer.text(d, null, null, b.useHTML).css(b.style).attr({align: this.textAlign, rotation: b.rotation, visibility: Ra}).add(a)
    }, setOffset: function (a, b) {
        var c, d = this, e = d.axis, f = e.chart, g = f.inverted, h = e.reversed, i = this.isNegative && !h || !this.isNegative && h, j = e.translate(e.usePercentage ? 100 : this.total, 0, 0, 0, 1), k = e.translate(0), l = ra(j - k), m = f.xAxis[0].translate(this.x) + a, n = f.plotHeight, o = {x: g ? i ? j : j - l : m, y: g ? n - m - b : i ? n - j - l : n - j, width: g ? l : b, height: g ? b : l}, p = this.label;
        p && (p.align(this.alignOptions, null, o), c = p.alignAttr, p[this.options.crop === !1 || f.isInsidePlot(c.x, c.y) ? "show" : "hide"](!0))
    }}, Rb.prototype.getStacks = function () {
        var a = this;
        lb(a.yAxis, function (a) {
            a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks)
        }), lb(a.series, function (b) {
            !b.options.stacking || b.visible !== !0 && a.options.chart.ignoreHiddenSeries !== !1 || (b.stackKey = b.type + eb(b.options.stack, ""))
        })
    }, Hb.prototype.buildStacks = function () {
        var a = this.series, b = eb(this.options.reversedStacks, !0), c = a.length;
        if (!this.isXAxis) {
            for (this.usePercentage = !1; c--;)a[b ? c : a.length - c - 1].setStackedPoints();
            if (this.usePercentage)for (c = 0; c < a.length; c++)a[c].setPercentStacks()
        }
    }, Hb.prototype.renderStackTotals = function () {
        var a, b, c, d = this, e = d.chart, f = e.renderer, g = d.stacks, h = d.stackTotalGroup;
        h || (d.stackTotalGroup = h = f.g("stack-labels").attr({visibility: Ta, zIndex: 6}).add()), h.translate(e.plotLeft, e.plotTop);
        for (a in g) {
            b = g[a];
            for (c in b)b[c].render(h)
        }
    }, Hb.prototype.resetStacks = function () {
        var a, b, c = this.stacks;
        if (!this.isXAxis)for (a in c)for (b in c[a])c[a][b].touched < this.stacksTouched ? (c[a][b].destroy(), delete c[a][b]) : (c[a][b].total = null, c[a][b].cum = 0)
    }, Hb.prototype.cleanStacks = function () {
        var a, b, c;
        if (!this.isXAxis) {
            this.oldStacks && (a = this.stacks = this.oldStacks);
            for (b in a)for (c in a[b])a[b][c].cum = a[b][c].total
        }
    }, Ub.prototype.setStackedPoints = function () {
        if (this.options.stacking && (this.visible === !0 || this.chart.options.chart.ignoreHiddenSeries === !1)) {
            var a, b, c, d, e, f, g, h, i, j = this, k = j.processedXData, l = j.processedYData, m = [], n = l.length, o = j.options, p = o.threshold, q = o.startFromThreshold ? p : 0, r = o.stack, s = o.stacking, t = j.stackKey, u = "-" + t, v = j.negStacks, w = j.yAxis, x = w.stacks, y = w.oldStacks;
            for (w.stacksTouched += 1, g = 0; n > g; g++)h = k[g], i = l[g], a = j.getStackIndicator(a, h, j.index), f = a.key, b = v && (q ? 0 : p) > i, e = b ? u : t, x[e] || (x[e] = {}), x[e][h] || (y[e] && y[e][h] ? (x[e][h] = y[e][h], x[e][h].total = null) : x[e][h] = new J(w, w.options.stackLabels, b, h, r)), c = x[e][h], c.points[f] = [eb(c.cum, q)], c.touched = w.stacksTouched, "percent" === s ? (d = b ? t : u, v && x[d] && x[d][h] ? (d = x[d][h], c.total = d.total = pa(d.total, c.total) + ra(i) || 0) : c.total = C(c.total + (ra(i) || 0))) : c.total = C(c.total + (i || 0)), c.cum = eb(c.cum, q) + (i || 0), c.points[f].push(c.cum), m[g] = c.cum;
            "percent" === s && (w.usePercentage = !0), this.stackedYData = m, w.oldStacks = {}
        }
    }, Ub.prototype.setPercentStacks = function () {
        var a, b = this, c = b.stackKey, d = b.yAxis.stacks, e = b.processedXData;
        lb([c, "-" + c], function (c) {
            for (var f, g, h, i, j = e.length; j--;)f = e[j], a = b.getStackIndicator(a, f, b.index), g = d[c] && d[c][f], h = g && g.points[a.key], h && (i = g.total ? 100 / g.total : 0, h[0] = C(h[0] * i), h[1] = C(h[1] * i), b.stackedYData[j] = h[1])
        })
    }, Ub.prototype.getStackIndicator = function (a, b, c) {
        return j(a) && a.x === b ? a.index++ : a = {x: b, index: 0}, a.key = [c, b, a.index].join(","), a
    }, db(Rb.prototype, {addSeries: function (a, b, c) {
        var d, e = this;
        return a && (b = eb(b, !0), rb(e, "addSeries", {options: a}, function () {
            d = e.initSeries(a), e.isDirtyLegend = !0, e.linkSeries(), b && e.redraw(c)
        })), d
    }, addAxis: function (b, c, d, e) {
        var f, g = c ? "xAxis" : "yAxis", h = this.options;
        f = new Hb(this, a(b, {index: this[g].length, isX: c})), h[g] = l(h[g] || {}), h[g].push(b), eb(d, !0) && this.redraw(e)
    }, showLoading: function (a) {
        var b = this, c = b.options, d = b.loadingDiv, e = c.loading, f = function () {
            d && m(d, {left: b.plotLeft + Ua, top: b.plotTop + Ua, width: b.plotWidth + Ua, height: b.plotHeight + Ua})
        };
        d || (b.loadingDiv = d = n(Oa, {className: Sa + "loading"}, db(e.style, {zIndex: 10, display: Va}), b.container), b.loadingSpan = n("span", null, e.labelStyle, d), pb(b, "redraw", f)), b.loadingSpan.innerHTML = a || c.lang.loading, b.loadingShown || (m(d, {opacity: 0, display: ""}), tb(d, {opacity: e.style.opacity}, {duration: e.showDuration || 0}), b.loadingShown = !0), f()
    }, hideLoading: function () {
        var a = this.options, b = this.loadingDiv;
        b && tb(b, {opacity: 0}, {duration: a.loading.hideDuration || 100, complete: function () {
            m(b, {display: Va})
        }}), this.loadingShown = !1
    }}), db(Tb.prototype, {update: function (a, b, c, f) {
        function g() {
            i.applyOptions(a), null === i.y && k && (i.graphic = k.destroy()), d(a) && !e(a) && (i.redraw = function () {
                k && k.element && a && a.marker && a.marker.symbol && (i.graphic = k.destroy()), a && a.dataLabels && i.dataLabel && (i.dataLabel = i.dataLabel.destroy()), i.redraw = null
            }), h = i.index, j.updateParallelArrays(i, h), n && i.name && (n[i.x] = i.name), m.data[h] = i.options, j.isDirty = j.isDirtyData = !0, !j.fixedBox && j.hasCartesianSeries && (l.isDirtyBox = !0), "point" === m.legendType && (l.isDirtyLegend = !0), b && l.redraw(c)
        }

        var h, i = this, j = i.series, k = i.graphic, l = j.chart, m = j.options, n = j.xAxis && j.xAxis.names;
        b = eb(b, !0), f === !1 ? g() : i.firePointEvent("update", {options: a}, g)
    }, remove: function (a, b) {
        this.series.removePoint(kb(this, this.series.data), a, b)
    }}), db(Ub.prototype, {addPoint: function (a, b, c, d) {
        var e, f, g, h, i = this, j = i.options, k = i.data, l = i.graph, m = i.area, n = i.chart, o = i.xAxis && i.xAxis.names, p = l && l.shift || 0, q = ["graph", "area"], r = j.data, s = i.xData;
        if (D(d, n), c) {
            for (g = i.zones.length; g--;)q.push("zoneGraph" + g, "zoneArea" + g);
            lb(q, function (a) {
                i[a] && (i[a].shift = p + (j.step ? 2 : 1))
            })
        }
        if (m && (m.isArea = !0), b = eb(b, !0), e = {series: i}, i.pointClass.prototype.applyOptions.apply(e, [a]), h = e.x, g = s.length, i.requireSorting && h < s[g - 1])for (f = !0; g && s[g - 1] > h;)g--;
        i.updateParallelArrays(e, "splice", g, 0, 0), i.updateParallelArrays(e, g), o && e.name && (o[h] = e.name), r.splice(g, 0, a), f && (i.data.splice(g, 0, null), i.processData()), "point" === j.legendType && i.generatePoints(), c && (k[0] && k[0].remove ? k[0].remove(!1) : (k.shift(), i.updateParallelArrays(e, "shift"), r.shift())), i.isDirty = !0, i.isDirtyData = !0, b && (i.getAttribs(), n.redraw())
    }, removePoint: function (a, b, c) {
        var d = this, e = d.data, f = e[a], g = d.points, h = d.chart, i = function () {
            e.length === g.length && g.splice(a, 1), e.splice(a, 1), d.options.data.splice(a, 1), d.updateParallelArrays(f || {series: d}, "splice", a, 1), f && f.destroy(), d.isDirty = !0, d.isDirtyData = !0, b && h.redraw()
        };
        D(c, h), b = eb(b, !0), f ? f.firePointEvent("remove", null, i) : i()
    }, remove: function (a, b) {
        var c = this, d = c.chart;
        a = eb(a, !0), c.isRemoving || (c.isRemoving = !0, rb(c, "remove", null, function () {
            c.destroy(), d.isDirtyLegend = d.isDirtyBox = !0, d.linkSeries(), a && d.redraw(b)
        })), c.isRemoving = !1
    }, update: function (b, c) {
        var d, e = this, f = this.chart, g = this.userOptions, h = this.type, i = cb[h].prototype, j = ["group", "markerGroup", "dataLabelsGroup"];
        (b.type && b.type !== h || void 0 !== b.zIndex) && (j.length = 0), lb(j, function (a) {
            j[a] = e[a], delete e[a]
        }), b = a(g, {animation: !1, index: this.index, pointStart: this.xData[0]}, {data: this.options.data}, b), this.remove(!1);
        for (d in i)this[d] = K;
        db(this, cb[b.type || h].prototype), lb(j, function (a) {
            e[a] = j[a]
        }), this.init(f, b), f.linkSeries(), eb(c, !0) && f.redraw(!1)
    }}), db(Hb.prototype, {update: function (b, c) {
        var d = this.chart;
        b = d.options[this.coll][this.options.index] = a(this.userOptions, b), this.destroy(!0), this._addedPlotLB = this.chart._labelPanes = K, this.init(d, db(b, {events: K})), d.isDirtyBox = !0, eb(c, !0) && d.redraw()
    }, remove: function (a) {
        for (var b = this.chart, c = this.coll, d = this.series, e = d.length; e--;)d[e] && d[e].remove(!1);
        i(b.axes, this), i(b[c], this), b.options[c].splice(this.options.index, 1), lb(b[c], function (a, b) {
            a.options.index = b
        }), this.destroy(), b.isDirtyBox = !0, eb(a, !0) && b.redraw()
    }, setTitle: function (a, b) {
        this.update({title: a}, b)
    }, setCategories: function (a, b) {
        this.update({categories: a}, b)
    }});
    var Vb = o(Ub);
    cb.line = Vb, vb.area = a(wb, {softThreshold: !1, threshold: 0});
    var Wb = o(Ub, {type: "area", getSegments: function () {
        var a, b, c, d, e, f = this, g = [], h = [], i = [], j = this.xAxis, k = this.yAxis, l = k.stacks[this.stackKey], m = {}, n = this.points, o = this.options.connectNulls;
        if (this.options.stacking && !this.cropped) {
            for (d = 0; d < n.length; d++)m[n[d].x] = n[d];
            for (e in l)null !== l[e].total && i.push(+e);
            i.sort(function (a, b) {
                return a - b
            }), lb(i, function (e) {
                var g, i = null;
                if (!o || m[e] && null !== m[e].y)if (m[e])h.push(m[e]); else {
                    for (d = f.index; d <= k.series.length; d++)if (c = f.getStackIndicator(null, e, d), g = l[e].points[c.key]) {
                        i = g[1];
                        break
                    }
                    a = j.translate(e), b = k.getThreshold(i), h.push({y: null, plotX: a, clientX: a, plotY: b, yBottom: b, onMouseOver: Ja})
                }
            }), h.length && g.push(h)
        } else Ub.prototype.getSegments.call(this), g = this.segments;
        this.segments = g
    }, getSegmentPath: function (a) {
        var b, c, d = Ub.prototype.getSegmentPath.call(this, a), e = [].concat(d), f = this.options, g = d.length, h = this.yAxis.getThreshold(f.threshold);
        if (3 === g && e.push(Xa, d[1], d[2]), f.stacking && !this.closedStacks)for (b = a.length - 1; b >= 0; b--)c = eb(a[b].yBottom, h), b < a.length - 1 && f.step && e.push(a[b + 1].plotX, c), e.push(a[b].plotX, c); else this.closeSegment(e, a, h);
        return this.areaPath = this.areaPath.concat(e), d
    }, closeSegment: function (a, b, c) {
        a.push(Xa, b[b.length - 1].plotX, c, Xa, b[0].plotX, c)
    }, drawGraph: function () {
        this.areaPath = [], Ub.prototype.drawGraph.apply(this);
        var a = this, b = this.areaPath, c = this.options, d = this.zones, e = [
            ["area", this.color, c.fillColor]
        ];
        lb(d, function (b, d) {
            e.push(["zoneArea" + d, b.color || a.color, b.fillColor || c.fillColor])
        }), lb(e, function (d) {
            var e = d[0], f = a[e];
            f ? f.animate({d: b}) : a[e] = a.chart.renderer.path(b).attr({fill: eb(d[2], Ab(d[1]).setOpacity(eb(c.fillOpacity, .75)).get()), zIndex: 0}).add(a.group)
        })
    }, drawLegendSymbol: Qb.drawRectangle});
    cb.area = Wb, vb.spline = a(wb);
    var Xb = o(Ub, {type: "spline", getPointSpline: function (a, b, c) {
        var d, e, f, g, h, i = 1.5, j = i + 1, k = b.plotX, l = b.plotY, m = a[c - 1], n = a[c + 1];
        if (m && n) {
            var o, p = m.plotX, q = m.plotY, r = n.plotX, s = n.plotY;
            d = (i * k + p) / j, e = (i * l + q) / j, f = (i * k + r) / j, g = (i * l + s) / j, o = (g - e) * (f - k) / (f - d) + l - g, e += o, g += o, e > q && e > l ? (e = pa(q, l), g = 2 * l - e) : q > e && l > e && (e = qa(q, l), g = 2 * l - e), g > s && g > l ? (g = pa(s, l), e = 2 * l - g) : s > g && l > g && (g = qa(s, l), e = 2 * l - g), b.rightContX = f, b.rightContY = g
        }
        return c ? (h = ["C", m.rightContX || m.plotX, m.rightContY || m.plotY, d || k, e || l, k, l], m.rightContX = m.rightContY = null) : h = [Wa, k, l], h
    }});
    cb.spline = Xb, vb.areaspline = a(vb.area);
    var Yb = Wb.prototype, Zb = o(Xb, {type: "areaspline", closedStacks: !0, getSegmentPath: Yb.getSegmentPath, closeSegment: Yb.closeSegment, drawGraph: Yb.drawGraph, drawLegendSymbol: Qb.drawRectangle});
    cb.areaspline = Zb, vb.column = a(wb, {borderColor: "#FFFFFF", borderRadius: 0, groupPadding: .2, marker: null, pointPadding: .1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: {hover: {brightness: .1, shadow: !1, halo: !1}, select: {color: "#C0C0C0", borderColor: "#000000", shadow: !1}}, dataLabels: {align: null, verticalAlign: null, y: null}, softThreshold: !1, startFromThreshold: !0, stickyTracking: !1, tooltip: {distance: 6}, threshold: 0});
    var $b = o(Ub, {type: "column", pointAttrToOptions: {stroke: "borderColor", fill: "color", r: "borderRadius"}, cropShoulder: 0, directTouch: !0, trackerGroups: ["group", "dataLabelsGroup"], negStacks: !0, init: function () {
        Ub.prototype.init.apply(this, arguments);
        var a = this, b = a.chart;
        b.hasRendered && lb(b.series, function (b) {
            b.type === a.type && (b.isDirty = !0)
        })
    }, getColumnMetrics: function () {
        var a, b, c = this, d = c.options, e = c.xAxis, f = c.yAxis, g = e.reversed, h = {}, i = 0;
        d.grouping === !1 ? i = 1 : lb(c.chart.series, function (d) {
            var e = d.options, g = d.yAxis;
            d.type === c.type && d.visible && f.len === g.len && f.pos === g.pos && (e.stacking ? (a = d.stackKey, h[a] === K && (h[a] = i++), b = h[a]) : e.grouping !== !1 && (b = i++), d.columnIndex = b)
        });
        var j = qa(ra(e.transA) * (e.ordinalSlope || d.pointRange || e.closestPointRange || e.tickInterval || 1), e.len), k = j * d.groupPadding, l = j - 2 * k, m = l / i, n = qa(d.maxPointWidth || e.len, eb(d.pointWidth, m * (1 - 2 * d.pointPadding))), o = (m - n) / 2, p = (g ? i - (c.columnIndex || 0) : c.columnIndex) || 0, q = o + (k + p * m - j / 2) * (g ? -1 : 1);
        return c.columnMetrics = {width: n, offset: q}
    }, crispCol: function (a, b, c, d) {
        var e, f, g, h = this.chart, i = this.borderWidth, j = -(i % 2 ? .5 : 0), k = i % 2 ? .5 : 1;
        return h.inverted && h.renderer.isVML && (k += 1), e = Math.round(a + c) + j, a = Math.round(a) + j, c = e - a, g = ra(b) <= .5, f = Math.round(b + d) + k, b = Math.round(b) + k, d = f - b, g && (b -= 1, d += 1), {x: a, y: b, width: c, height: d}
    }, translate: function () {
        var a = this, b = a.chart, c = a.options, d = a.borderWidth = eb(c.borderWidth, a.closestPointRange * a.xAxis.transA < 2 ? 0 : 1), e = a.yAxis, f = c.threshold, g = a.translatedThreshold = e.getThreshold(f), h = eb(c.minPointLength, 5), i = a.getColumnMetrics(), j = i.width, k = a.barW = pa(j, 1 + 2 * d), l = a.pointXOffset = i.offset;
        b.inverted && (g -= .5), c.pointPadding && (k = oa(k)), Ub.prototype.translate.apply(a), lb(a.points, function (c) {
            var d, f = qa(eb(c.yBottom, g), 9e4), i = 999 + ra(f), m = qa(pa(-i, c.plotY), e.len + i), n = c.plotX + l, o = k, p = qa(m, f), q = pa(m, f) - p;
            ra(q) < h && h && (q = h, d = !e.reversed && !c.negative || e.reversed && c.negative, p = ra(p - g) > h ? f - h : g - (d ? h : 0)), c.barX = n, c.pointWidth = j, c.tooltipPos = b.inverted ? [e.len + e.pos - b.plotLeft - m, a.xAxis.len - n - o / 2, q] : [n + o / 2, m + e.pos - b.plotTop, q], c.shapeType = "rect", c.shapeArgs = a.crispCol(n, p, o, q)
        })
    }, getSymbol: Ja, drawLegendSymbol: Qb.drawRectangle, drawGraph: Ja, drawPoints: function () {
        var b, c, d = this, e = this.chart, f = d.options, g = e.renderer, h = f.animationLimit || 250;
        lb(d.points, function (i) {
            var k, l = i.plotY, m = i.graphic;
            l === K || isNaN(l) || null === i.y ? m && (i.graphic = m.destroy()) : (b = i.shapeArgs, k = j(d.borderWidth) ? {"stroke-width": d.borderWidth} : {}, c = i.pointAttr[i.selected ? _a : Za] || d.pointAttr[Za], m ? (ub(m), m.attr(k)[e.pointCount < h ? "animate" : "attr"](a(b))) : i.graphic = m = g[i.shapeType](b).attr(k).attr(c).add(i.group || d.group).shadow(f.shadow, null, f.stacking && !f.borderRadius))
        })
    }, animate: function (a) {
        var b, c = this, d = this.yAxis, e = c.options, f = this.chart.inverted, g = {};
        Ea && (a ? (g.scaleY = .001, b = qa(d.pos + d.len, pa(d.pos, d.toPixels(e.threshold))), f ? g.translateX = b - d.len : g.translateY = b, c.group.attr(g)) : (g.scaleY = 1, g[f ? "translateX" : "translateY"] = d.pos, c.group.animate(g, c.options.animation), c.animate = null))
    }, remove: function () {
        var a = this, b = a.chart;
        b.hasRendered && lb(b.series, function (b) {
            b.type === a.type && (b.isDirty = !0)
        }), Ub.prototype.remove.apply(a, arguments)
    }});
    cb.column = $b, vb.bar = a(vb.column);
    var _b = o($b, {type: "bar", inverted: !0});
    cb.bar = _b, vb.scatter = a(wb, {lineWidth: 0, marker: {enabled: !0}, tooltip: {headerFormat: '<span style="color:{point.color}">●</span> <span style="font-size: 10px;"> {series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>"}});
    var ac = o(Ub, {type: "scatter", sorted: !1, requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["group", "markerGroup", "dataLabelsGroup"], takeOrdinalPosition: !1, kdDimensions: 2, drawGraph: function () {
        this.options.lineWidth && Ub.prototype.drawGraph.call(this)
    }});
    cb.scatter = ac, vb.pie = a(wb, {borderColor: "#FFFFFF", borderWidth: 1, center: [null, null], clip: !1, colorByPoint: !0, dataLabels: {distance: 30, enabled: !0, formatter: function () {
        return null === this.y ? void 0 : this.point.name
    }, x: 0}, ignoreHiddenPoint: !0, legendType: "point", marker: null, size: null, showInLegend: !1, slicedOffset: 10, states: {hover: {brightness: .1, shadow: !1}}, stickyTracking: !1, tooltip: {followPointer: !0}});
    var bc = o(Tb, {init: function () {
        Tb.prototype.init.apply(this, arguments);
        var a, b = this;
        return b.name = eb(b.name, "Slice"), a = function (a) {
            b.slice("select" === a.type)
        }, pb(b, "select", a), pb(b, "unselect", a), b
    }, setVisible: function (a, b) {
        var c = this, d = c.series, e = d.chart, f = d.options.ignoreHiddenPoint;
        b = eb(b, f), a !== c.visible && (c.visible = c.options.visible = a = a === K ? !c.visible : a, d.options.data[kb(c, d.data)] = c.options, lb(["graphic", "dataLabel", "connector", "shadowGroup"], function (b) {
            c[b] && c[b][a ? "show" : "hide"](!0)
        }), c.legendItem && e.legend.colorizeItem(c, a), a || "hover" !== c.state || c.setState(""), f && (d.isDirty = !0), b && e.redraw())
    }, slice: function (a, b, c) {
        var d, e = this, f = e.series, g = f.chart;
        D(c, g), b = eb(b, !0), e.sliced = e.options.sliced = a = j(a) ? a : !e.sliced, f.options.data[kb(e, f.data)] = e.options, d = a ? e.slicedTranslation : {translateX: 0, translateY: 0}, e.graphic.animate(d), e.shadowGroup && e.shadowGroup.animate(d)
    }, haloPath: function (a) {
        var b = this.shapeArgs, c = this.series.chart;
        return this.sliced || !this.visible ? [] : this.series.chart.renderer.symbols.arc(c.plotLeft + b.x, c.plotTop + b.y, b.r + a, b.r + a, {innerR: this.shapeArgs.r, start: b.start, end: b.end})
    }}), cc = {type: "pie", isCartesian: !1, pointClass: bc, requireSorting: !1, directTouch: !0, noSharedTooltip: !0, trackerGroups: ["group", "dataLabelsGroup"], axisTypes: [], pointAttrToOptions: {stroke: "borderColor", "stroke-width": "borderWidth", fill: "color"}, animate: function (a) {
        var b = this, c = b.points, d = b.startAngleRad;
        a || (lb(c, function (a) {
            var c = a.graphic, e = a.shapeArgs;
            c && (c.attr({r: a.startR || b.center[3] / 2, start: d, end: d}), c.animate({r: e.r, start: e.start, end: e.end}, b.options.animation))
        }), b.animate = null)
    }, updateTotals: function () {
        var a, b, c = 0, d = this.points, e = d.length, f = this.options.ignoreHiddenPoint;
        for (a = 0; e > a; a++)b = d[a], c += f && !b.visible ? 0 : b.y;
        for (this.total = c, a = 0; e > a; a++)b = d[a], b.percentage = c > 0 && (b.visible || !f) ? b.y / c * 100 : 0, b.total = c
    }, generatePoints: function () {
        Ub.prototype.generatePoints.call(this), this.updateTotals()
    }, translate: function (a) {
        this.generatePoints();
        var b, c, d, e, f, g, h, i = this, j = 0, k = 1e3, l = i.options, m = l.slicedOffset, n = m + l.borderWidth, o = l.startAngle || 0, p = i.startAngleRad = ua / 180 * (o - 90), q = i.endAngleRad = ua / 180 * (eb(l.endAngle, o + 360) - 90), r = q - p, s = i.points, t = l.dataLabels.distance, u = l.ignoreHiddenPoint, v = s.length;
        for (a || (i.center = a = i.getCenter()), i.getX = function (b, c) {
            return d = la.asin(qa((b - a[1]) / (a[2] / 2 + t), 1)), a[0] + (c ? -1 : 1) * (sa(d) * (a[2] / 2 + t))
        }, g = 0; v > g; g++)h = s[g], b = p + j * r, (!u || h.visible) && (j += h.percentage / 100), c = p + j * r, h.shapeType = "arc", h.shapeArgs = {x: a[0], y: a[1], r: a[2] / 2, innerR: a[3] / 2, start: ma(b * k) / k, end: ma(c * k) / k}, d = (c + b) / 2, d > 1.5 * ua ? d -= 2 * ua : -ua / 2 > d && (d += 2 * ua), h.slicedTranslation = {translateX: ma(sa(d) * m), translateY: ma(ta(d) * m)}, e = sa(d) * a[2] / 2, f = ta(d) * a[2] / 2, h.tooltipPos = [a[0] + .7 * e, a[1] + .7 * f], h.half = -ua / 2 > d || d > ua / 2 ? 1 : 0, h.angle = d, n = qa(n, t / 2), h.labelPos = [a[0] + e + sa(d) * t, a[1] + f + ta(d) * t, a[0] + e + sa(d) * n, a[1] + f + ta(d) * n, a[0] + e, a[1] + f, 0 > t ? "center" : h.half ? "right" : "left", d]
    }, drawGraph: null, drawPoints: function () {
        var a, b, c, d, e, f = this, g = f.chart, h = g.renderer, i = f.options.shadow;
        i && !f.shadowGroup && (f.shadowGroup = h.g("shadow").add(f.group)), lb(f.points, function (g) {
            null !== g.y && (b = g.graphic, d = g.shapeArgs, c = g.shadowGroup, i && !c && (c = g.shadowGroup = h.g("shadow").add(f.shadowGroup)), a = g.sliced ? g.slicedTranslation : {translateX: 0, translateY: 0}, c && c.attr(a), b ? b.setRadialReference(f.center).animate(db(d, a)) : (e = {"stroke-linejoin": "round"}, g.visible || (e.visibility = "hidden"), g.graphic = b = h[g.shapeType](d).setRadialReference(f.center).attr(g.pointAttr[g.selected ? _a : Za]).attr(e).attr(a).add(f.group).shadow(i, c)))
        })
    }, searchPoint: Ja, sortByAngle: function (a, b) {
        a.sort(function (a, c) {
            return void 0 !== a.angle && (c.angle - a.angle) * b
        })
    }, drawLegendSymbol: Qb.drawRectangle, getCenter: Sb.getCenter, getSymbol: Ja};
    cc = o(Ub, cc), cb.pie = cc, Ub.prototype.drawDataLabels = function () {
        var b, c, d, e, f = this, g = f.options, h = g.cursor, i = g.dataLabels, k = f.points, l = f.hasRendered || 0, m = f.chart.renderer;
        (i.enabled || f._hasPointLabels) && (f.dlProcessOptions && f.dlProcessOptions(i), e = f.plotGroup("dataLabelsGroup", "data-labels", i.defer ? Ra : Ta, i.zIndex || 6), eb(i.defer, !0) && (e.attr({opacity: +l}), l || pb(f, "afterAnimate", function () {
            f.visible && e.show(), e[g.animation ? "animate" : "attr"]({opacity: 1}, {duration: 200})
        })), c = i, lb(k, function (k) {
            var l, n, o, p, q, r, s = k.dataLabel, u = k.connector, v = !0, w = {};
            if (b = k.dlOptions || k.options && k.options.dataLabels, l = eb(b && b.enabled, c.enabled), s && !l)k.dataLabel = s.destroy(); else if (l) {
                if (i = a(c, b), r = i.style, q = i.rotation, n = k.getLabelConfig(), d = i.format ? t(i.format, n) : i.formatter.call(n, i), r.color = eb(i.color, r.color, f.color, "black"), s)j(d) ? (s.attr({text: d}), v = !1) : (k.dataLabel = s = s.destroy(), u && (k.connector = u.destroy())); else if (j(d)) {
                    o = {fill: i.backgroundColor, stroke: i.borderColor, "stroke-width": i.borderWidth, r: i.borderRadius || 0, rotation: q, padding: i.padding, zIndex: 1}, "contrast" === r.color && (w.color = i.inside || i.distance < 0 || g.stacking ? m.getContrast(k.color || f.color) : "#000000"), h && (w.cursor = h);
                    for (p in o)o[p] === K && delete o[p];
                    s = k.dataLabel = m[q ? "text" : "label"](d, 0, -999, i.shape, null, null, i.useHTML).attr(o).css(db(r, w)).add(e).shadow(i.shadow)
                }
                s && f.alignDataLabel(k, s, i, null, v)
            }
        }))
    }, Ub.prototype.alignDataLabel = function (a, b, c, d, e) {
        var f, g, h = this.chart, i = h.inverted, j = eb(a.plotX, -999), k = eb(a.plotY, -999), l = b.getBBox(), m = h.renderer.fontMetrics(c.style.fontSize).b, n = this.visible && (a.series.forceDL || h.isInsidePlot(j, ma(k), i) || d && h.isInsidePlot(j, i ? d.x + 1 : d.y + d.height - 1, i));
        n && (d = db({x: i ? h.plotWidth - k : j, y: ma(i ? h.plotHeight - j : k), width: 0, height: 0}, d), db(c, {width: l.width, height: l.height}), c.rotation ? (f = h.renderer.rotCorr(m, c.rotation), b[e ? "attr" : "animate"]({x: d.x + c.x + d.width / 2 + f.x, y: d.y + c.y + d.height / 2}).attr({align: c.align})) : (b.align(c, null, d), g = b.alignAttr, "justify" === eb(c.overflow, "justify") ? this.justifyDataLabel(b, c, g, l, d, e) : eb(c.crop, !0) && (n = h.isInsidePlot(g.x, g.y) && h.isInsidePlot(g.x + l.width, g.y + l.height)), c.shape && b.attr({anchorX: a.plotX, anchorY: a.plotY}))), n || (ub(b), b.attr({y: -999}), b.placed = !1)
    }, Ub.prototype.justifyDataLabel = function (a, b, c, d, e, f) {
        var g, h, i = this.chart, j = b.align, k = b.verticalAlign, l = a.box ? 0 : a.padding || 0;
        g = c.x + l, 0 > g && ("right" === j ? b.align = "left" : b.x = -g, h = !0), g = c.x + d.width - l, g > i.plotWidth && ("left" === j ? b.align = "right" : b.x = i.plotWidth - g, h = !0), g = c.y + l, 0 > g && ("bottom" === k ? b.verticalAlign = "top" : b.y = -g, h = !0), g = c.y + d.height - l, g > i.plotHeight && ("top" === k ? b.verticalAlign = "bottom" : b.y = i.plotHeight - g, h = !0), h && (a.placed = !f, a.align(b, null, e))
    }, cb.pie && (cb.pie.prototype.drawDataLabels = function () {
        var a, b, c, d, e, f, g, h, i, j, k, l, m, n = this, o = n.data, p = n.chart, q = n.options.dataLabels, r = eb(q.connectorPadding, 10), s = eb(q.connectorWidth, 1), t = p.plotWidth, u = p.plotHeight, v = eb(q.softConnector, !0), w = q.distance, x = n.center, z = x[2] / 2, A = x[1], B = w > 0, C = [
            [],
            []
        ], D = [0, 0, 0, 0], E = function (a, b) {
            return b.y - a.y
        };
        if (n.visible && (q.enabled || n._hasPointLabels)) {
            for (Ub.prototype.drawDataLabels.apply(n), lb(o, function (a) {
                a.dataLabel && a.visible && C[a.half].push(a)
            }), l = 2; l--;) {
                var F, G, H, I, J = [], K = [], L = C[l], M = L.length;
                if (M) {
                    for (n.sortByAngle(L, l - .5), m = g = 0; !g && L[m];)g = L[m] && L[m].dataLabel && (L[m].dataLabel.getBBox().height || 21), m++;
                    if (w > 0) {
                        for (H = qa(A + z + w, p.plotHeight), G = pa(0, A - z - w); H >= G; G += g)J.push(G);
                        if (F = J.length, M > F) {
                            for (k = [].concat(L), k.sort(E), m = M; m--;)k[m].rank = m;
                            for (m = M; m--;)L[m].rank >= F && L.splice(m, 1);
                            M = L.length
                        }
                        for (m = 0; M > m; m++) {
                            a = L[m], f = a.labelPos;
                            var N, O, P = 9999;
                            for (O = 0; F > O; O++)N = ra(J[O] - f[1]), P > N && (P = N, I = O);
                            if (m > I && null !== J[m])I = m; else if (M - m + I > F && null !== J[m])for (I = F - M + m; null === J[I];)I++; else for (; null === J[I];)I++;
                            K.push({i: I, y: J[I]}), J[I] = null
                        }
                        K.sort(E)
                    }
                    for (m = 0; M > m; m++) {
                        var Q, R;
                        a = L[m], f = a.labelPos, d = a.dataLabel, j = a.visible === !1 ? Ra : "inherit", R = f[1], w > 0 ? (Q = K.pop(), I = Q.i, i = Q.y, (R > i && null !== J[I + 1] || i > R && null !== J[I - 1]) && (i = qa(pa(0, R), p.plotHeight))) : i = R, h = q.justify ? x[0] + (l ? -1 : 1) * (z + w) : n.getX(i === A - z - w || i === A + z + w ? R : i, l), d._attr = {visibility: j, align: f[6]}, d._pos = {x: h + q.x + ({left: r, right: -r}[f[6]] || 0), y: i + q.y - 10}, d.connX = h, d.connY = i, null === this.options.size && (e = d.width, r > h - e ? D[3] = pa(ma(e - h + r), D[3]) : h + e > t - r && (D[1] = pa(ma(h + e - t + r), D[1])), 0 > i - g / 2 ? D[0] = pa(ma(-i + g / 2), D[0]) : i + g / 2 > u && (D[2] = pa(ma(i + g / 2 - u), D[2])))
                    }
                }
            }
            (0 === y(D) || this.verifyDataLabelOverflow(D)) && (this.placeDataLabels(), B && s && lb(this.points, function (a) {
                b = a.connector, f = a.labelPos, d = a.dataLabel, d && d._pos && a.visible ? (j = d._attr.visibility, h = d.connX, i = d.connY, c = v ? [Wa, h + ("left" === f[6] ? 5 : -5), i, "C", h, i, 2 * f[2] - f[4], 2 * f[3] - f[5], f[2], f[3], Xa, f[4], f[5]] : [Wa, h + ("left" === f[6] ? 5 : -5), i, Xa, f[2], f[3], Xa, f[4], f[5]], b ? (b.animate({d: c}), b.attr("visibility", j)) : a.connector = b = n.chart.renderer.path(c).attr({"stroke-width": s, stroke: q.connectorColor || a.color || "#606060", visibility: j}).add(n.dataLabelsGroup)) : b && (a.connector = b.destroy())
            }))
        }
    }, cb.pie.prototype.placeDataLabels = function () {
        lb(this.points, function (a) {
            var b, c = a.dataLabel;
            c && a.visible && (b = c._pos, b ? (c.attr(c._attr), c[c.moved ? "animate" : "attr"](b), c.moved = !0) : c && c.attr({y: -999}))
        })
    }, cb.pie.prototype.alignDataLabel = Ja, cb.pie.prototype.verifyDataLabelOverflow = function (a) {
        var b, c = this.center, d = this.options, e = d.center, f = d.minSize || 80, g = f;
        return null !== e[0] ? g = pa(c[2] - pa(a[1], a[3]), f) : (g = pa(c[2] - a[1] - a[3], f), c[0] += (a[3] - a[1]) / 2), null !== e[1] ? g = pa(qa(g, c[2] - pa(a[0], a[2])), f) : (g = pa(qa(g, c[2] - a[0] - a[2]), f), c[1] += (a[0] - a[2]) / 2), g < c[2] ? (c[2] = g, c[3] = Math.min(q(d.innerSize || 0, g), g), this.translate(c), lb(this.points, function (a) {
            a.dataLabel && (a.dataLabel._pos = null)
        }), this.drawDataLabels && this.drawDataLabels()) : b = !0, b
    }), cb.column && (cb.column.prototype.alignDataLabel = function (b, c, d, e, f) {
        var g = this.chart.inverted, h = b.series, i = b.dlBox || b.shapeArgs, j = eb(b.below, b.plotY > eb(this.translatedThreshold, h.yAxis.len)), k = eb(d.inside, !!this.options.stacking);
        i && (e = a(i), g && (e = {x: h.yAxis.len - e.y - e.height, y: h.xAxis.len - e.x - e.width, width: e.height, height: e.width}), k || (g ? (e.x += j ? 0 : e.width, e.width = 0) : (e.y += j ? e.height : 0, e.height = 0))), d.align = eb(d.align, !g || k ? "center" : j ? "right" : "left"), d.verticalAlign = eb(d.verticalAlign, g || k ? "middle" : j ? "top" : "bottom"), Ub.prototype.alignDataLabel.call(this, b, c, d, e, f)
    }), function (a) {
        var b = a.Chart, c = a.each, d = a.pick, e = HighchartsAdapter.addEvent;
        b.prototype.callbacks.push(function (a) {
            function b() {
                var b = [];
                c(a.series, function (a) {
                    var e = a.options.dataLabels, f = a.dataLabelCollections || ["dataLabel"];
                    (e.enabled || a._hasPointLabels) && !e.allowOverlap && a.visible && c(f, function (e) {
                        c(a.points, function (a) {
                            a[e] && (a[e].labelrank = d(a.labelrank, a.shapeArgs && a.shapeArgs.height), b.push(a[e]))
                        })
                    })
                }), a.hideOverlappingLabels(b)
            }

            b(), e(a, "redraw", b)
        }), b.prototype.hideOverlappingLabels = function (a) {
            var b, d, e, f, g, h, i, j, k, l = a.length, m = function (a, b, c, d, e, f, g, h) {
                return!(e > a + c || a > e + g || f > b + d || b > f + h)
            };
            for (d = 0; l > d; d++)b = a[d], b && (b.oldOpacity = b.opacity, b.newOpacity = 1);
            for (a.sort(function (a, b) {
                return(b.labelrank || 0) - (a.labelrank || 0)
            }), d = 0; l > d; d++)for (f = a[d], e = d + 1; l > e; ++e)g = a[e], f && g && f.placed && g.placed && 0 !== f.newOpacity && 0 !== g.newOpacity && (i = f.alignAttr, j = g.alignAttr, k = 2 * (f.box ? 0 : f.padding), h = m(i.x, i.y, f.width - k, f.height - k, j.x, j.y, g.width - k, g.height - k), h && ((f.labelrank < g.labelrank ? f : g).newOpacity = 0));
            c(a, function (a) {
                var b, c;
                a && (c = a.newOpacity, a.oldOpacity !== c && a.placed && (c ? a.show(!0) : b = function () {
                    a.hide()
                }, a.alignAttr.opacity = c, a[a.isOld ? "animate" : "attr"](a.alignAttr, null, b)), a.isOld = !0)
            })
        }
    }(ia);
    var dc = ia.TrackerMixin = {drawTrackerPoint: function () {
        var a = this, b = a.chart, c = b.pointer, d = a.options.cursor, e = d && {cursor: d}, f = function (a) {
            for (var c, d = a.target; d && !c;)c = d.point, d = d.parentNode;
            c !== K && c !== b.hoverPoint && c.onMouseOver(a)
        };
        lb(a.points, function (a) {
            a.graphic && (a.graphic.element.point = a), a.dataLabel && (a.dataLabel.element.point = a)
        }), a._hasTracking || (lb(a.trackerGroups, function (b) {
            a[b] && (a[b].addClass(Sa + "tracker").on("mouseover", f).on("mouseout", function (a) {
                c.onTrackerMouseOut(a)
            }).css(e), M && a[b].on("touchstart", f))
        }), a._hasTracking = !0)
    }, drawTrackerGraph: function () {
        var a, b, c = this, d = c.options, e = d.trackByArea, f = [].concat(e ? c.areaPath : c.graphPath), g = f.length, h = c.chart, i = h.pointer, j = h.renderer, k = h.options.tooltip.snap, l = c.tracker, m = d.cursor, n = m && {cursor: m}, o = c.singlePoints, p = function () {
            h.hoverSeries !== c && c.onMouseOver()
        }, q = "rgba(192,192,192," + (Ea ? 1e-4 : .002) + ")";
        if (g && !e)for (b = g + 1; b--;)f[b] === Wa && f.splice(b + 1, 0, f[b + 1] - k, f[b + 2], Xa), (b && f[b] === Wa || b === g) && f.splice(b, 0, Xa, f[b - 2] + k, f[b - 1]);
        for (b = 0; b < o.length; b++)a = o[b], f.push(Wa, a.plotX - k, a.plotY, Xa, a.plotX + k, a.plotY);
        l ? l.attr({d: f}) : (c.tracker = j.path(f).attr({"stroke-linejoin": "round", visibility: c.visible ? Ta : Ra, stroke: q, fill: e ? q : Va, "stroke-width": d.lineWidth + (e ? 0 : 2 * k), zIndex: 2}).add(c.group), lb([c.tracker, c.markerGroup], function (a) {
            a.addClass(Sa + "tracker").on("mouseover", p).on("mouseout", function (a) {
                i.onTrackerMouseOut(a)
            }).css(n), M && a.on("touchstart", p)
        }))
    }};
    cb.column && ($b.prototype.drawTracker = dc.drawTrackerPoint), cb.pie && (cb.pie.prototype.drawTracker = dc.drawTrackerPoint), cb.scatter && (ac.prototype.drawTracker = dc.drawTrackerPoint), db(Pb.prototype, {setItemEvents: function (a, b, c, d, e) {
        var f = this;
        (c ? b : a.legendGroup).on("mouseover", function () {
            a.setState($a), b.css(f.options.itemHoverStyle)
        }).on("mouseout", function () {
            b.css(a.visible ? d : e), a.setState()
        }).on("click", function (b) {
            var c = "legendItemClick", d = function () {
                a.setVisible && a.setVisible()
            };
            b = {browserEvent: b}, a.firePointEvent ? a.firePointEvent(c, b, d) : rb(a, c, b, d)
        })
    }, createCheckboxForItem: function (a) {
        var b = this;
        a.checkbox = n("input", {type: "checkbox", checked: a.selected, defaultChecked: a.selected}, b.options.itemCheckboxStyle, b.chart.container), pb(a.checkbox, "click", function (b) {
            var c = b.target;
            rb(a.series || a, "checkboxClick", {checked: c.checked, item: a}, function () {
                a.select()
            })
        })
    }}), O.legend.itemStyle.cursor = "pointer", db(Rb.prototype, {showResetZoom: function () {
        var a = this, b = O.lang, c = a.options.chart.resetZoomButton, d = c.theme, e = d.states, f = "chart" === c.relativeTo ? null : "plotBox";
        this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function () {
            a.zoomOut()
        }, d, e && e.hover).attr({align: c.position.align, title: b.resetZoomTitle}).add().align(c.position, !1, f)
    }, zoomOut: function () {
        var a = this;
        rb(a, "selection", {resetSelection: !0}, function () {
            a.zoom()
        })
    }, zoom: function (a) {
        var b, c, e = this, f = e.pointer, g = !1;
        !a || a.resetSelection ? lb(e.axes, function (a) {
            b = a.zoom()
        }) : lb(a.xAxis.concat(a.yAxis), function (a) {
            var c = a.axis, d = c.isXAxis;
            (f[d ? "zoomX" : "zoomY"] || f[d ? "pinchX" : "pinchY"]) && (b = c.zoom(a.min, a.max), c.displayBtn && (g = !0))
        }), c = e.resetZoomButton, g && !c ? e.showResetZoom() : !g && d(c) && (e.resetZoomButton = c.destroy()), b && e.redraw(eb(e.options.chart.animation, a && a.animation, e.pointCount < 100))
    }, pan: function (a, b) {
        var c, d = this, e = d.hoverPoints;
        e && lb(e, function (a) {
            a.setState()
        }), lb("xy" === b ? [1, 0] : [1], function (b) {
            var e = a[b ? "chartX" : "chartY"], f = d[b ? "xAxis" : "yAxis"][0], g = d[b ? "mouseDownX" : "mouseDownY"], h = (f.pointRange || 0) / 2, i = f.getExtremes(), j = f.toValue(g - e, !0) + h, k = f.toValue(g + d[b ? "plotWidth" : "plotHeight"] - e, !0) - h, l = g > e;
            f.series.length && (l || j > qa(i.dataMin, i.min)) && (!l || k < pa(i.dataMax, i.max)) && (f.setExtremes(j, k, !1, !1, {trigger: "pan"}), c = !0), d[b ? "mouseDownX" : "mouseDownY"] = e
        }), c && d.redraw(!1), m(d.container, {cursor: "move"})
    }}), db(Tb.prototype, {select: function (a, b) {
        var c = this, d = c.series, e = d.chart;
        a = eb(a, !c.selected), c.firePointEvent(a ? "select" : "unselect", {accumulate: b}, function () {
            c.selected = c.options.selected = a, d.options.data[kb(c, d.data)] = c.options, c.setState(a && _a), b || lb(e.getSelectedPoints(), function (a) {
                a.selected && a !== c && (a.selected = a.options.selected = !1, d.options.data[kb(a, d.data)] = a.options, a.setState(Za), a.firePointEvent("unselect"))
            })
        })
    }, onMouseOver: function (a, b) {
        var c = this, d = c.series, e = d.chart, f = e.tooltip, g = e.hoverPoint;
        e.hoverSeries !== d && d.onMouseOver(), g && g !== c && g.onMouseOut(), c.series && (c.firePointEvent("mouseOver"), !f || f.shared && !d.noSharedTooltip || f.refresh(c, a), c.setState($a), b || (e.hoverPoint = c))
    }, onMouseOut: function () {
        var a = this.series.chart, b = a.hoverPoints;
        this.firePointEvent("mouseOut"), b && -1 !== kb(this, b) || (this.setState(),
            a.hoverPoint = null)
    }, importEvents: function () {
        if (!this.hasImportedEvents) {
            var b, c = this, d = a(c.series.options.point, c.options), e = d.events;
            c.events = e;
            for (b in e)pb(c, b, e[b]);
            this.hasImportedEvents = !0
        }
    }, setState: function (b, c) {
        var d, e, f, g, h = this, i = na(h.plotX), j = h.plotY, k = h.series, l = k.options.states, m = vb[k.type].marker && k.options.marker, n = m && !m.enabled, o = m && m.states[b], p = o && o.enabled === !1, q = k.stateMarkerGraphic, r = h.marker || {}, s = k.chart, t = k.halo;
        b = b || Za, g = h.pointAttr[b] || k.pointAttr[b], b === h.state && !c || h.selected && b !== _a || l[b] && l[b].enabled === !1 || b && (p || n && o.enabled === !1) || b && r.states && r.states[b] && r.states[b].enabled === !1 || (h.graphic ? (d = m && h.graphic.symbolName && g.r, h.graphic.attr(a(g, d ? {x: i - d, y: j - d, width: 2 * d, height: 2 * d} : {})), q && q.hide()) : (b && o && (d = o.radius, f = r.symbol || k.symbol, q && q.currentSymbol !== f && (q = q.destroy()), q ? q[c ? "animate" : "attr"]({x: i - d, y: j - d}) : f && (k.stateMarkerGraphic = q = s.renderer.symbol(f, i - d, j - d, 2 * d, 2 * d).attr(g).add(k.markerGroup), q.currentSymbol = f)), q && (q[b && s.isInsidePlot(i, j, s.inverted) ? "show" : "hide"](), q.element.point = h)), e = l[b] && l[b].halo, e && e.size ? (t || (k.halo = t = s.renderer.path().add(s.seriesGroup)), t.attr(db({fill: Ab(h.color || k.color).setOpacity(e.opacity).get()}, e.attributes))[c ? "animate" : "attr"]({d: h.haloPath(e.size)})) : t && t.attr({d: []}), h.state = b)
    }, haloPath: function (a) {
        var b = this.series, c = b.chart, d = b.getPlotBox(), e = c.inverted;
        return c.renderer.symbols.circle(d.translateX + (e ? b.yAxis.len - this.plotY : this.plotX) - a, d.translateY + (e ? b.xAxis.len - this.plotX : this.plotY) - a, 2 * a, 2 * a)
    }}), db(Ub.prototype, {onMouseOver: function () {
        var a = this, b = a.chart, c = b.hoverSeries;
        c && c !== a && c.onMouseOut(), a.options.events.mouseOver && rb(a, "mouseOver"), a.setState($a), b.hoverSeries = a
    }, onMouseOut: function () {
        var a = this, b = a.options, c = a.chart, d = c.tooltip, e = c.hoverPoint;
        c.hoverSeries = null, e && e.onMouseOut(), a && b.events.mouseOut && rb(a, "mouseOut"), !d || b.stickyTracking || d.shared && !a.noSharedTooltip || d.hide(), a.setState()
    }, setState: function (a) {
        var b, c = this, d = c.options, e = c.graph, f = d.states, g = d.lineWidth, h = 0;
        if (a = a || Za, c.state !== a) {
            if (c.state = a, f[a] && f[a].enabled === !1)return;
            if (a && (g = f[a].lineWidth || g + (f[a].lineWidthPlus || 0)), e && !e.dashstyle)for (b = {"stroke-width": g}, e.attr(b); c["zoneGraph" + h];)c["zoneGraph" + h].attr(b), h += 1
        }
    }, setVisible: function (a, b) {
        var c, d = this, e = d.chart, f = d.legendItem, g = e.options.chart.ignoreHiddenSeries, h = d.visible;
        d.visible = a = d.userOptions.visible = a === K ? !h : a, c = a ? "show" : "hide", lb(["group", "dataLabelsGroup", "markerGroup", "tracker"], function (a) {
            d[a] && d[a][c]()
        }), (e.hoverSeries === d || (e.hoverPoint && e.hoverPoint.series) === d) && d.onMouseOut(), f && e.legend.colorizeItem(d, a), d.isDirty = !0, d.options.stacking && lb(e.series, function (a) {
            a.options.stacking && a.visible && (a.isDirty = !0)
        }), lb(d.linkedSeries, function (b) {
            b.setVisible(a, !1)
        }), g && (e.isDirtyBox = !0), b !== !1 && e.redraw(), rb(d, c)
    }, show: function () {
        this.setVisible(!0)
    }, hide: function () {
        this.setVisible(!1)
    }, select: function (a) {
        var b = this;
        b.selected = a = a === K ? !b.selected : a, b.checkbox && (b.checkbox.checked = a), rb(b, a ? "select" : "unselect")
    }, drawTracker: dc.drawTrackerGraph}), db(ia, {Color: Ab, Point: Tb, Tick: I, Renderer: L, SVGElement: H, SVGRenderer: Bb, arrayMin: x, arrayMax: y, charts: Ka, dateFormat: P, error: B, format: t, pathAnim: Q, getOptions: G, hasBidiBug: Fa, isTouchDevice: Ca, setOptions: F, addEvent: pb, removeEvent: qb, createElement: n, discardElement: A, css: m, each: lb, map: ob, merge: a, splat: l, extendClass: o, pInt: b, svg: Ea, canvas: Ga, vml: !Ea && !Ga, product: Ma, version: Na})
}();